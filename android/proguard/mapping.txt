com.badlogic.gdx.Application -> com.badlogic.gdx.a:
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> a
    com.badlogic.gdx.Graphics getGraphics() -> b
    void log(java.lang.String,java.lang.String) -> a
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void debug(java.lang.String,java.lang.String) -> c
    void setLogLevel(int) -> a
    com.badlogic.gdx.Application$ApplicationType getType() -> c
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    void postRunnable(java.lang.Runnable) -> a
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> b
com.badlogic.gdx.Application$ApplicationType -> com.badlogic.gdx.b:
    com.badlogic.gdx.Application$ApplicationType Android -> a
    com.badlogic.gdx.Application$ApplicationType Desktop -> b
    com.badlogic.gdx.Application$ApplicationType HeadlessDesktop -> c
    com.badlogic.gdx.Application$ApplicationType Applet -> d
    com.badlogic.gdx.Application$ApplicationType WebGL -> e
    com.badlogic.gdx.Application$ApplicationType iOS -> f
    com.badlogic.gdx.Application$ApplicationType[] $VALUES -> g
    com.badlogic.gdx.Application$ApplicationType[] values() -> values
    com.badlogic.gdx.Application$ApplicationType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.ApplicationListener -> com.badlogic.gdx.c:
    void create() -> a
    void resize(int,int) -> a
    void render() -> b
    void pause() -> c
    void resume() -> d
    void dispose() -> e
com.badlogic.gdx.Audio -> com.badlogic.gdx.d:
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> b
com.badlogic.gdx.Files -> com.badlogic.gdx.e:
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> a
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle local(java.lang.String) -> c
    java.lang.String getExternalStoragePath() -> a
    java.lang.String getLocalStoragePath() -> b
com.badlogic.gdx.Files$FileType -> com.badlogic.gdx.f:
    com.badlogic.gdx.Files$FileType Classpath -> a
    com.badlogic.gdx.Files$FileType Internal -> b
    com.badlogic.gdx.Files$FileType External -> c
    com.badlogic.gdx.Files$FileType Absolute -> d
    com.badlogic.gdx.Files$FileType Local -> e
    com.badlogic.gdx.Files$FileType[] $VALUES -> f
    com.badlogic.gdx.Files$FileType[] values() -> values
    com.badlogic.gdx.Files$FileType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Gdx -> com.badlogic.gdx.g:
    com.badlogic.gdx.Application app -> a
    com.badlogic.gdx.Graphics graphics -> b
    com.badlogic.gdx.Audio audio -> c
    com.badlogic.gdx.Input input -> d
    com.badlogic.gdx.Files files -> e
    com.badlogic.gdx.Net net -> f
    com.badlogic.gdx.graphics.GL20 gl -> g
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    com.badlogic.gdx.graphics.GL30 gl30 -> i
com.badlogic.gdx.Graphics -> com.badlogic.gdx.h:
    int getWidth() -> a
    int getHeight() -> b
    float getDeltaTime() -> c
    com.badlogic.gdx.Graphics$DisplayMode getDesktopDisplayMode() -> d
    boolean supportsExtension(java.lang.String) -> a
    boolean isContinuousRendering() -> e
    void requestRendering() -> f
com.badlogic.gdx.Graphics$BufferFormat -> com.badlogic.gdx.i:
    int r -> a
    int g -> b
    int b -> c
    int a -> d
    int depth -> e
    int stencil -> f
    int samples -> g
    boolean coverageSampling -> h
    java.lang.String toString() -> toString
com.badlogic.gdx.Graphics$DisplayMode -> com.badlogic.gdx.j:
    int width -> a
    int height -> b
    int refreshRate -> c
    int bitsPerPixel -> d
    java.lang.String toString() -> toString
com.badlogic.gdx.Input -> com.badlogic.gdx.k:
    int getX() -> a
    int getY() -> b
    boolean isTouched() -> c
    boolean isTouched(int) -> a
    boolean isButtonPressed(int) -> b
    boolean isKeyPressed(int) -> c
    long getCurrentEventTime() -> d
    void setCatchBackKey(boolean) -> a
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
com.badlogic.gdx.Input$Orientation -> com.badlogic.gdx.l:
    com.badlogic.gdx.Input$Orientation Landscape -> a
    com.badlogic.gdx.Input$Orientation Portrait -> b
    com.badlogic.gdx.Input$Orientation[] $VALUES -> c
    com.badlogic.gdx.Input$Orientation[] values() -> values
    com.badlogic.gdx.Input$Orientation valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Input$TextInputListener -> com.badlogic.gdx.m:
com.badlogic.gdx.InputAdapter -> com.badlogic.gdx.n:
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
com.badlogic.gdx.InputMultiplexer -> com.badlogic.gdx.o:
    com.badlogic.gdx.utils.Array processors -> a
    void addProcessor(com.badlogic.gdx.InputProcessor) -> a
    void removeProcessor(com.badlogic.gdx.InputProcessor) -> b
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
com.badlogic.gdx.InputProcessor -> com.badlogic.gdx.p:
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
com.badlogic.gdx.LifecycleListener -> com.badlogic.gdx.q:
    void pause() -> a
    void resume() -> b
    void dispose() -> c
com.badlogic.gdx.Net -> com.badlogic.gdx.r:
com.badlogic.gdx.Preferences -> com.badlogic.gdx.s:
    com.badlogic.gdx.Preferences putBoolean(java.lang.String,boolean) -> a
    boolean getBoolean(java.lang.String,boolean) -> b
    void flush() -> a
com.badlogic.gdx.assets.AssetDescriptor -> com.badlogic.gdx.a.a:
    java.lang.String fileName -> a
    java.lang.Class type -> b
    com.badlogic.gdx.assets.AssetLoaderParameters params -> c
    com.badlogic.gdx.files.FileHandle file -> d
    java.lang.String toString() -> toString
com.badlogic.gdx.assets.AssetErrorListener -> com.badlogic.gdx.a.b:
    void error(com.badlogic.gdx.assets.AssetDescriptor,java.lang.Throwable) -> a
com.badlogic.gdx.assets.AssetLoaderParameters -> com.badlogic.gdx.a.c:
    com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback loadedCallback -> a
com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback -> com.badlogic.gdx.a.d:
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.assets.AssetLoadingTask -> com.badlogic.gdx.a.e:
    com.badlogic.gdx.assets.AssetManager manager -> a
    com.badlogic.gdx.assets.AssetDescriptor assetDesc -> b
    com.badlogic.gdx.assets.loaders.AssetLoader loader -> c
    com.badlogic.gdx.utils.async.AsyncExecutor executor -> d
    long startTime -> e
    boolean asyncDone -> f
    boolean dependenciesLoaded -> g
    com.badlogic.gdx.utils.Array dependencies -> h
    com.badlogic.gdx.utils.async.AsyncResult depsFuture -> i
    com.badlogic.gdx.utils.async.AsyncResult loadFuture -> j
    java.lang.Object asset -> k
    int ticks -> l
    boolean cancel -> m
    java.lang.Void call() -> a
    boolean update() -> b
    void handleSyncLoader() -> e
    void handleAsyncLoader() -> f
    com.badlogic.gdx.files.FileHandle resolve(com.badlogic.gdx.assets.loaders.AssetLoader,com.badlogic.gdx.assets.AssetDescriptor) -> a
    java.lang.Object getAsset() -> c
    java.lang.Object call() -> d
com.badlogic.gdx.assets.AssetManager -> com.badlogic.gdx.a.f:
    com.badlogic.gdx.utils.ObjectMap assets -> a
    com.badlogic.gdx.utils.ObjectMap assetTypes -> b
    com.badlogic.gdx.utils.ObjectMap assetDependencies -> c
    com.badlogic.gdx.utils.ObjectSet injected -> d
    com.badlogic.gdx.utils.ObjectMap loaders -> e
    com.badlogic.gdx.utils.Array loadQueue -> f
    com.badlogic.gdx.utils.async.AsyncExecutor executor -> g
    java.util.Stack tasks -> h
    com.badlogic.gdx.assets.AssetErrorListener listener -> i
    int loaded -> j
    int toLoad -> k
    com.badlogic.gdx.utils.Logger log -> l
    java.lang.Object get(java.lang.String) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    void unload(java.lang.String) -> b
    java.lang.String getAssetFileName(java.lang.Object) -> a
    boolean isLoaded(java.lang.String) -> c
    com.badlogic.gdx.assets.loaders.AssetLoader getLoader(java.lang.Class,java.lang.String) -> a
    void load(java.lang.String,java.lang.Class) -> b
    void load(java.lang.String,java.lang.Class,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    boolean update() -> a
    void finishLoading() -> b
    void injectDependencies(java.lang.String,com.badlogic.gdx.utils.Array) -> a
    void injectDependency(java.lang.String,com.badlogic.gdx.assets.AssetDescriptor) -> a
    void nextTask() -> f
    void addTask(com.badlogic.gdx.assets.AssetDescriptor) -> a
    void addAsset(java.lang.String,java.lang.Class,java.lang.Object) -> a
    boolean updateTask() -> g
    void incrementRefCountedDependencies(java.lang.String) -> f
    void handleTaskError(java.lang.Throwable) -> a
    void setLoader(java.lang.Class,com.badlogic.gdx.assets.loaders.AssetLoader) -> a
    void setLoader(java.lang.Class,java.lang.String,com.badlogic.gdx.assets.loaders.AssetLoader) -> a
    void setErrorListener(com.badlogic.gdx.assets.AssetErrorListener) -> a
    void dispose() -> c
    void clear() -> d
    int getReferenceCount(java.lang.String) -> d
    void setReferenceCount(java.lang.String,int) -> a
    com.badlogic.gdx.utils.Array getAssetNames() -> e
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String) -> e
com.badlogic.gdx.assets.RefCountedContainer -> com.badlogic.gdx.a.g:
    java.lang.Object object -> a
    int refCount -> b
    void incRefCount() -> a
    void decRefCount() -> b
    int getRefCount() -> c
    void setRefCount(int) -> a
    java.lang.Object getObject(java.lang.Class) -> a
com.badlogic.gdx.assets.loaders.AssetLoader -> com.badlogic.gdx.a.a.a:
    com.badlogic.gdx.assets.loaders.FileHandleResolver resolver -> a
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader -> com.badlogic.gdx.a.a.b:
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.BitmapFontLoader -> com.badlogic.gdx.a.a.c:
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter -> com.badlogic.gdx.a.a.d:
    boolean flip -> b
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData bitmapFontData -> f
com.badlogic.gdx.assets.loaders.FileHandleResolver -> com.badlogic.gdx.a.a.e:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.I18NBundleLoader -> com.badlogic.gdx.a.a.f:
    com.badlogic.gdx.utils.I18NBundle bundle -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> a
    com.badlogic.gdx.utils.I18NBundle loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter -> com.badlogic.gdx.a.a.g:
    java.util.Locale locale -> b
    java.lang.String encoding -> c
com.badlogic.gdx.assets.loaders.ModelLoader -> com.badlogic.gdx.a.a.h:
    com.badlogic.gdx.utils.Array items -> a
    com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters defaultParameters -> b
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.graphics.g3d.Model loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters -> com.badlogic.gdx.a.a.i:
    com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter textureParameter -> b
com.badlogic.gdx.assets.loaders.MusicLoader -> com.badlogic.gdx.a.a.j:
    com.badlogic.gdx.audio.Music music -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> a
    com.badlogic.gdx.audio.Music loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter -> com.badlogic.gdx.a.a.k:
com.badlogic.gdx.assets.loaders.ParticleEffectLoader -> com.badlogic.gdx.a.a.l:
    com.badlogic.gdx.graphics.g2d.ParticleEffect load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter -> com.badlogic.gdx.a.a.m:
    java.lang.String atlasFile -> b
    java.lang.String atlasPrefix -> c
    com.badlogic.gdx.files.FileHandle imagesDir -> d
com.badlogic.gdx.assets.loaders.PixmapLoader -> com.badlogic.gdx.a.a.n:
    com.badlogic.gdx.graphics.Pixmap pixmap -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> a
    com.badlogic.gdx.graphics.Pixmap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter -> com.badlogic.gdx.a.a.o:
com.badlogic.gdx.assets.loaders.SkinLoader -> com.badlogic.gdx.a.a.p:
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter -> com.badlogic.gdx.a.a.q:
    java.lang.String textureAtlasPath -> b
    com.badlogic.gdx.utils.ObjectMap resources -> c
com.badlogic.gdx.assets.loaders.SoundLoader -> com.badlogic.gdx.a.a.r:
    com.badlogic.gdx.audio.Sound sound -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> a
    com.badlogic.gdx.audio.Sound loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter -> com.badlogic.gdx.a.a.s:
com.badlogic.gdx.assets.loaders.SynchronousAssetLoader -> com.badlogic.gdx.a.a.t:
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureAtlasLoader -> com.badlogic.gdx.a.a.u:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData data -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter -> com.badlogic.gdx.a.a.v:
    boolean flip -> b
com.badlogic.gdx.assets.loaders.TextureLoader -> com.badlogic.gdx.a.a.w:
    com.badlogic.gdx.assets.loaders.TextureLoader$TextureLoaderInfo info -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> a
    com.badlogic.gdx.graphics.Texture loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureLoader$TextureLoaderInfo -> com.badlogic.gdx.a.a.x:
    java.lang.String filename -> a
    com.badlogic.gdx.graphics.TextureData data -> b
    com.badlogic.gdx.graphics.Texture texture -> c
com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter -> com.badlogic.gdx.a.a.y:
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture texture -> d
    com.badlogic.gdx.graphics.TextureData textureData -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> g
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapU -> h
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapV -> i
com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver -> com.badlogic.gdx.a.a.a.a:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.audio.Music -> com.badlogic.gdx.b.a:
com.badlogic.gdx.audio.Music$OnCompletionListener -> com.badlogic.gdx.b.b:
    void onCompletion(com.badlogic.gdx.audio.Music) -> a
com.badlogic.gdx.audio.Sound -> com.badlogic.gdx.b.c:
com.badlogic.gdx.backends.android.AndroidApplication -> com.badlogic.gdx.backends.android.a:
    com.badlogic.gdx.backends.android.AndroidGraphics graphics -> a
    com.badlogic.gdx.backends.android.AndroidInput input -> b
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    com.badlogic.gdx.backends.android.AndroidFiles files -> d
    com.badlogic.gdx.backends.android.AndroidNet net -> e
    com.badlogic.gdx.ApplicationListener listener -> f
    android.os.Handler handler -> g
    boolean firstResume -> h
    com.badlogic.gdx.utils.Array runnables -> i
    com.badlogic.gdx.utils.Array executedRunnables -> j
    com.badlogic.gdx.utils.Array lifecycleListeners -> k
    int logLevel -> l
    boolean useImmersiveMode -> m
    boolean hideStatusBar -> n
    int wasFocusChanged -> o
    boolean isWaitingForAudio -> p
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    void init(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration,boolean) -> a
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> d
    void createWakeLock(boolean) -> a
    void hideStatusBar(boolean) -> b
    void onWindowFocusChanged(boolean) -> onWindowFocusChanged
    void useImmersiveMode(boolean) -> c
    void onPause() -> onPause
    void onResume() -> onResume
    void onDestroy() -> onDestroy
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> a
    com.badlogic.gdx.Audio getAudio() -> e
    com.badlogic.gdx.Files getFiles() -> f
    com.badlogic.gdx.Graphics getGraphics() -> b
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> g
    com.badlogic.gdx.Net getNet() -> h
    com.badlogic.gdx.Application$ApplicationType getType() -> c
    int getVersion() -> i
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    void postRunnable(java.lang.Runnable) -> a
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void debug(java.lang.String,java.lang.String) -> c
    void log(java.lang.String,java.lang.String) -> a
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void setLogLevel(int) -> a
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> b
    android.content.Context getContext() -> j
    com.badlogic.gdx.utils.Array getRunnables() -> k
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> l
    com.badlogic.gdx.utils.Array getLifecycleListeners() -> m
com.badlogic.gdx.backends.android.AndroidApplication$1 -> com.badlogic.gdx.backends.android.b:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> a
    void resume() -> b
    void pause() -> a
    void dispose() -> c
com.badlogic.gdx.backends.android.AndroidApplicationBase -> com.badlogic.gdx.backends.android.c:
    android.content.Context getContext() -> j
    com.badlogic.gdx.utils.Array getRunnables() -> k
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> l
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> g
    com.badlogic.gdx.utils.Array getLifecycleListeners() -> m
    android.view.WindowManager getWindowManager() -> getWindowManager
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration -> com.badlogic.gdx.backends.android.d:
    int r -> a
    int g -> b
    int b -> c
    int a -> d
    int depth -> e
    int stencil -> f
    int numSamples -> g
    boolean useAccelerometer -> h
    boolean useCompass -> i
    int touchSleepTime -> j
    boolean useWakelock -> k
    boolean hideStatusBar -> l
    boolean disableAudio -> m
    int maxSimultaneousSounds -> n
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> o
    boolean getTouchEventsForLiveWallpaper -> p
    boolean useImmersiveMode -> q
    boolean useGLSurfaceView20API18 -> r
com.badlogic.gdx.backends.android.AndroidAudio -> com.badlogic.gdx.backends.android.e:
    android.media.SoundPool soundPool -> b
    android.media.AudioManager manager -> c
    java.util.List musics -> a
    void pause() -> a
    void resume() -> b
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> a
    void dispose() -> c
com.badlogic.gdx.backends.android.AndroidFileHandle -> com.badlogic.gdx.backends.android.f:
    android.content.res.AssetManager assets -> a
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle parent() -> a
    java.io.InputStream read() -> b
    boolean exists() -> c
    long length() -> d
    java.io.File file() -> e
com.badlogic.gdx.backends.android.AndroidFiles -> com.badlogic.gdx.backends.android.g:
    java.lang.String sdcard -> a
    java.lang.String localpath -> b
    android.content.res.AssetManager assets -> c
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> a
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle local(java.lang.String) -> c
    java.lang.String getExternalStoragePath() -> a
    java.lang.String getLocalStoragePath() -> b
com.badlogic.gdx.backends.android.AndroidGL20 -> com.badlogic.gdx.backends.android.AndroidGL20:
    void init() -> init
    void glAttachShader(int,int) -> glAttachShader
    void glBindBuffer(int,int) -> glBindBuffer
    void glBindFramebuffer(int,int) -> glBindFramebuffer
    void glBindRenderbuffer(int,int) -> glBindRenderbuffer
    void glBindTexture(int,int) -> glBindTexture
    void glBlendFunc(int,int) -> glBlendFunc
    void glBufferData(int,int,java.nio.Buffer,int) -> glBufferData
    void glBufferSubData(int,int,int,java.nio.Buffer) -> glBufferSubData
    int glCheckFramebufferStatus(int) -> glCheckFramebufferStatus
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glCompileShader(int) -> glCompileShader
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    int glCreateProgram() -> glCreateProgram
    int glCreateShader(int) -> glCreateShader
    void glDeleteBuffers(int,java.nio.IntBuffer) -> glDeleteBuffers
    void glDeleteFramebuffers(int,java.nio.IntBuffer) -> glDeleteFramebuffers
    void glDeleteProgram(int) -> glDeleteProgram
    void glDeleteRenderbuffers(int,java.nio.IntBuffer) -> glDeleteRenderbuffers
    void glDeleteShader(int) -> glDeleteShader
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthMask(boolean) -> glDepthMask
    void glDisable(int) -> glDisable
    void glDisableVertexAttribArray(int) -> glDisableVertexAttribArray
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glDrawElements(int,int,int,int) -> glDrawElements
    void glEnable(int) -> glEnable
    void glEnableVertexAttribArray(int) -> glEnableVertexAttribArray
    void glFramebufferRenderbuffer(int,int,int,int) -> glFramebufferRenderbuffer
    void glFramebufferTexture2D(int,int,int,int,int) -> glFramebufferTexture2D
    void glGenBuffers(int,java.nio.IntBuffer) -> glGenBuffers
    void glGenerateMipmap(int) -> glGenerateMipmap
    void glGenFramebuffers(int,java.nio.IntBuffer) -> glGenFramebuffers
    void glGenRenderbuffers(int,java.nio.IntBuffer) -> glGenRenderbuffers
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveAttrib
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveUniform
    int glGetAttribLocation(int,java.lang.String) -> glGetAttribLocation
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> glGetProgramiv
    java.lang.String glGetProgramInfoLog(int) -> glGetProgramInfoLog
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> glGetShaderiv
    java.lang.String glGetShaderInfoLog(int) -> glGetShaderInfoLog
    java.lang.String glGetString(int) -> glGetString
    int glGetUniformLocation(int,java.lang.String) -> glGetUniformLocation
    void glLinkProgram(int) -> glLinkProgram
    void glPixelStorei(int,int) -> glPixelStorei
    void glRenderbufferStorage(int,int,int,int) -> glRenderbufferStorage
    void glScissor(int,int,int,int) -> glScissor
    void glShaderSource(int,java.lang.String) -> glShaderSource
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glUniform1i(int,int) -> glUniform1i
    void glUniformMatrix4fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix4fv
    void glUseProgram(int) -> glUseProgram
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> glVertexAttribPointer
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> glVertexAttribPointer
    void glViewport(int,int,int,int) -> glViewport
com.badlogic.gdx.backends.android.AndroidGraphics -> com.badlogic.gdx.backends.android.h:
    android.view.View view -> a
    int width -> b
    int height -> c
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> d
    com.badlogic.gdx.graphics.GL20 gl20 -> e
    javax.microedition.khronos.egl.EGLContext eglContext -> f
    java.lang.String extensions -> g
    long lastFrameTime -> h
    float deltaTime -> i
    long frameStart -> j
    int frames -> k
    int fps -> l
    com.badlogic.gdx.math.WindowedMean mean -> m
    boolean created -> n
    boolean running -> o
    boolean pause -> p
    boolean resume -> q
    boolean destroy -> r
    float ppiX -> v
    float ppiY -> w
    float ppcX -> x
    float ppcY -> y
    float density -> z
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> s
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> A
    boolean isContinuous -> B
    int[] value -> t
    java.lang.Object synch -> u
    void preserveEGLContextOnPause() -> g
    android.view.View createGLSurfaceView(com.badlogic.gdx.backends.android.AndroidApplicationBase,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> a
    void onPauseGLSurfaceView() -> h
    void onResumeGLSurfaceView() -> i
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> j
    void updatePpi() -> r
    boolean checkGL20() -> k
    int getHeight() -> b
    int getWidth() -> a
    void setupGL(javax.microedition.khronos.opengles.GL10) -> a
    void onSurfaceChanged(javax.microedition.khronos.opengles.GL10,int,int) -> onSurfaceChanged
    void onSurfaceCreated(javax.microedition.khronos.opengles.GL10,javax.microedition.khronos.egl.EGLConfig) -> onSurfaceCreated
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> a
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void resume() -> l
    void pause() -> m
    void destroy() -> n
    void onDrawFrame(javax.microedition.khronos.opengles.GL10) -> onDrawFrame
    float getDeltaTime() -> c
    void clearManagedCaches() -> o
    void logManagedCachesStatus() -> p
    android.view.View getView() -> q
    com.badlogic.gdx.Graphics$DisplayMode getDesktopDisplayMode() -> d
    boolean supportsExtension(java.lang.String) -> a
    void setContinuousRendering(boolean) -> a
    boolean isContinuousRendering() -> e
    void requestRendering() -> f
com.badlogic.gdx.backends.android.AndroidGraphics$AndroidDisplayMode -> com.badlogic.gdx.backends.android.i:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> e
com.badlogic.gdx.backends.android.AndroidInput -> com.badlogic.gdx.backends.android.j:
    com.badlogic.gdx.utils.Pool usedKeyEvents -> a
    com.badlogic.gdx.utils.Pool usedTouchEvents -> b
    java.util.ArrayList keyListeners -> c
    java.util.ArrayList keyEvents -> d
    java.util.ArrayList touchEvents -> e
    int[] touchX -> f
    int[] touchY -> g
    int[] deltaX -> h
    int[] deltaY -> i
    boolean[] touched -> j
    int[] realId -> k
    boolean hasMultitouch -> l
    int keyCount -> u
    boolean[] keys -> v
    boolean keyJustPressed -> w
    boolean[] justPressedKeys -> x
    android.hardware.SensorManager manager -> y
    boolean accelerometerAvailable -> m
    float[] accelerometerValues -> z
    java.lang.String text -> A
    com.badlogic.gdx.Input$TextInputListener textListener -> B
    android.os.Handler handle -> C
    com.badlogic.gdx.Application app -> n
    android.content.Context context -> o
    com.badlogic.gdx.backends.android.AndroidTouchHandler touchHandler -> D
    int sleepTime -> E
    boolean catchBack -> F
    boolean catchMenu -> G
    android.os.Vibrator vibrator -> p
    boolean compassAvailable -> H
    boolean keyboardAvailable -> q
    float[] magneticFieldValues -> I
    float azimuth -> J
    float pitch -> K
    float roll -> L
    float inclination -> M
    boolean justTouched -> N
    com.badlogic.gdx.InputProcessor processor -> O
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> P
    com.badlogic.gdx.Input$Orientation nativeOrientation -> Q
    long currentEventTimeStamp -> R
    com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard onscreenKeyboard -> S
    android.hardware.SensorEventListener accelerometerListener -> T
    android.hardware.SensorEventListener compassListener -> U
    boolean requestFocus -> r
    float[] R -> s
    float[] orientation -> t
    int getX() -> a
    int getY() -> b
    boolean isTouched(int) -> a
    boolean isKeyPressed(int) -> c
    boolean isTouched() -> c
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
    void processEvents() -> e
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
    boolean onKey(android.view.View,int,android.view.KeyEvent) -> onKey
    void setCatchBackKey(boolean) -> a
    boolean isButtonPressed(int) -> b
    void registerSensorListeners() -> f
    void unregisterSensorListeners() -> g
    int getFreePointerIndex() -> h
    int[] resize(int[]) -> a
    boolean[] resize(boolean[]) -> a
    int lookUpPointerIndex(int) -> d
    int getRotation() -> i
    long getCurrentEventTime() -> d
    void onPause() -> j
    void onResume() -> k
com.badlogic.gdx.backends.android.AndroidInput$1 -> com.badlogic.gdx.backends.android.k:
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> a
    com.badlogic.gdx.backends.android.AndroidInput$KeyEvent newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.backends.android.AndroidInput$2 -> com.badlogic.gdx.backends.android.l:
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> a
    com.badlogic.gdx.backends.android.AndroidInput$TouchEvent newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.backends.android.AndroidInput$KeyEvent -> com.badlogic.gdx.backends.android.m:
    long timeStamp -> a
    int type -> b
    int keyCode -> c
    char keyChar -> d
com.badlogic.gdx.backends.android.AndroidInput$SensorListener -> com.badlogic.gdx.backends.android.n:
    float[] accelerometerValues -> a
    float[] magneticFieldValues -> b
    com.badlogic.gdx.Input$Orientation nativeOrientation -> c
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> d
    void onAccuracyChanged(android.hardware.Sensor,int) -> onAccuracyChanged
    void onSensorChanged(android.hardware.SensorEvent) -> onSensorChanged
com.badlogic.gdx.backends.android.AndroidInput$TouchEvent -> com.badlogic.gdx.backends.android.o:
    long timeStamp -> a
    int type -> b
    int x -> c
    int y -> d
    int pointer -> e
com.badlogic.gdx.backends.android.AndroidInputFactory -> com.badlogic.gdx.backends.android.p:
    com.badlogic.gdx.backends.android.AndroidInput newAndroidInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
com.badlogic.gdx.backends.android.AndroidInputThreePlus -> com.badlogic.gdx.backends.android.q:
    java.util.ArrayList genericMotionListeners -> u
    boolean onGenericMotion(android.view.View,android.view.MotionEvent) -> onGenericMotion
com.badlogic.gdx.backends.android.AndroidMultiTouchHandler -> com.badlogic.gdx.backends.android.r:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.AndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.AndroidInput,int,int,int,int,long) -> a
    boolean supportsMultitouch(android.content.Context) -> a
com.badlogic.gdx.backends.android.AndroidMusic -> com.badlogic.gdx.backends.android.s:
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    android.media.MediaPlayer player -> d
    boolean isPrepared -> e
    boolean wasPlaying -> a
    float volume -> f
    com.badlogic.gdx.audio.Music$OnCompletionListener onCompletionListener -> b
    void dispose() -> c
    boolean isPlaying() -> a
    void pause() -> b
    void play() -> d
    void onCompletion(android.media.MediaPlayer) -> onCompletion
com.badlogic.gdx.backends.android.AndroidMusic$1 -> com.badlogic.gdx.backends.android.t:
    com.badlogic.gdx.backends.android.AndroidMusic this$0 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidNet -> com.badlogic.gdx.backends.android.u:
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> a
    com.badlogic.gdx.net.NetJavaImpl netJavaImpl -> b
com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard -> com.badlogic.gdx.backends.android.v:
    android.content.Context context -> a
    android.os.Handler handler -> b
    com.badlogic.gdx.backends.android.AndroidInput input -> c
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
    boolean onKey(android.view.View,int,android.view.KeyEvent) -> onKey
com.badlogic.gdx.backends.android.AndroidPreferences -> com.badlogic.gdx.backends.android.w:
    android.content.SharedPreferences sharedPrefs -> a
    android.content.SharedPreferences$Editor editor -> b
    com.badlogic.gdx.Preferences putBoolean(java.lang.String,boolean) -> a
    boolean getBoolean(java.lang.String,boolean) -> b
    void flush() -> a
    void edit() -> b
com.badlogic.gdx.backends.android.AndroidSound -> com.badlogic.gdx.backends.android.x:
    android.media.SoundPool soundPool -> a
    android.media.AudioManager manager -> b
    int soundId -> c
    com.badlogic.gdx.utils.IntArray streamIds -> d
    void dispose() -> c
com.badlogic.gdx.backends.android.AndroidTouchHandler -> com.badlogic.gdx.backends.android.y:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.AndroidInput) -> a
    boolean supportsMultitouch(android.content.Context) -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener -> com.badlogic.gdx.backends.android.z:
com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy -> com.badlogic.gdx.backends.android.a.a:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 -> com.badlogic.gdx.backends.android.a.b:
    java.lang.String TAG -> a
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> b
    void onMeasure(int,int) -> onMeasure
    android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo) -> onCreateInputConnection
    void init(boolean,int,int) -> a
    void checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$1 -> com.badlogic.gdx.backends.android.a.c:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 this$0 -> a
    boolean deleteSurroundingText(int,int) -> deleteSurroundingText
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ConfigChooser -> com.badlogic.gdx.backends.android.a.d:
    int EGL_OPENGL_ES2_BIT -> g
    int[] s_configAttribs2 -> h
    int mRedSize -> a
    int mGreenSize -> b
    int mBlueSize -> c
    int mAlphaSize -> d
    int mDepthSize -> e
    int mStencilSize -> f
    int[] mValue -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ContextFactory -> com.badlogic.gdx.backends.android.a.e:
    int EGL_CONTEXT_CLIENT_VERSION -> a
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> createContext
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> destroyContext
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18 -> com.badlogic.gdx.backends.android.a.f:
    java.lang.String TAG -> a
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> b
    void onMeasure(int,int) -> onMeasure
    android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo) -> onCreateInputConnection
    void init(boolean,int,int) -> a
    void checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18$1 -> com.badlogic.gdx.backends.android.a.g:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18 this$0 -> a
    boolean deleteSurroundingText(int,int) -> deleteSurroundingText
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18$ConfigChooser -> com.badlogic.gdx.backends.android.a.h:
    int EGL_OPENGL_ES2_BIT -> g
    int[] s_configAttribs2 -> h
    int mRedSize -> a
    int mGreenSize -> b
    int mBlueSize -> c
    int mAlphaSize -> d
    int mDepthSize -> e
    int mStencilSize -> f
    int[] mValue -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18$ContextFactory -> com.badlogic.gdx.backends.android.a.i:
    int EGL_CONTEXT_CLIENT_VERSION -> a
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 -> com.badlogic.gdx.backends.android.a.j:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThreadManager sGLThreadManager -> a
    java.lang.ref.WeakReference mThisWeakRef -> b
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread mGLThread -> c
    android.opengl.GLSurfaceView$Renderer mRenderer -> d
    boolean mDetached -> e
    android.opengl.GLSurfaceView$EGLConfigChooser mEGLConfigChooser -> f
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLContextFactory mEGLContextFactory -> g
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLWindowSurfaceFactory mEGLWindowSurfaceFactory -> h
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLWrapper mGLWrapper -> i
    int mDebugFlags -> j
    int mEGLContextClientVersion -> k
    boolean mPreserveEGLContextOnPause -> l
    void finalize() -> finalize
    void init() -> e
    void setGLWrapper(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLWrapper) -> setGLWrapper
    void setDebugFlags(int) -> setDebugFlags
    int getDebugFlags() -> getDebugFlags
    void setPreserveEGLContextOnPause(boolean) -> setPreserveEGLContextOnPause
    boolean getPreserveEGLContextOnPause() -> getPreserveEGLContextOnPause
    void setRenderer(android.opengl.GLSurfaceView$Renderer) -> setRenderer
    void setEGLContextFactory(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLContextFactory) -> setEGLContextFactory
    void setEGLWindowSurfaceFactory(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLWindowSurfaceFactory) -> setEGLWindowSurfaceFactory
    void setEGLConfigChooser(android.opengl.GLSurfaceView$EGLConfigChooser) -> setEGLConfigChooser
    void setEGLConfigChooser(boolean) -> setEGLConfigChooser
    void setEGLConfigChooser(int,int,int,int,int,int) -> a
    void setEGLContextClientVersion(int) -> setEGLContextClientVersion
    void setRenderMode(int) -> setRenderMode
    int getRenderMode() -> getRenderMode
    void requestRender() -> a
    void surfaceCreated(android.view.SurfaceHolder) -> surfaceCreated
    void surfaceDestroyed(android.view.SurfaceHolder) -> surfaceDestroyed
    void surfaceChanged(android.view.SurfaceHolder,int,int,int) -> surfaceChanged
    void onPause() -> b
    void onResume() -> c
    void onAttachedToWindow() -> onAttachedToWindow
    void onDetachedFromWindow() -> onDetachedFromWindow
    void checkRenderThreadState() -> f
    int access$200(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> a
    android.opengl.GLSurfaceView$EGLConfigChooser access$300(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> b
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLContextFactory access$400(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> c
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLWindowSurfaceFactory access$500(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> d
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLWrapper access$600(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> e
    int access$700(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> f
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThreadManager access$800() -> d
    boolean access$900(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> g
    android.opengl.GLSurfaceView$Renderer access$1000(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> h
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$1 -> com.badlogic.gdx.backends.android.a.k:
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$BaseConfigChooser -> com.badlogic.gdx.backends.android.a.l:
    int[] mConfigSpec -> a
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 this$0 -> b
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int[] filterConfigSpec(int[]) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$ComponentSizeChooser -> com.badlogic.gdx.backends.android.a.m:
    int[] mValue -> j
    int mRedSize -> c
    int mGreenSize -> d
    int mBlueSize -> e
    int mAlphaSize -> f
    int mDepthSize -> g
    int mStencilSize -> h
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 this$0 -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$DefaultContextFactory -> com.badlogic.gdx.backends.android.a.n:
    int EGL_CONTEXT_CLIENT_VERSION -> b
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 this$0 -> a
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$DefaultWindowSurfaceFactory -> com.badlogic.gdx.backends.android.a.o:
    javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object) -> a
    void destroySurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLContextFactory -> com.badlogic.gdx.backends.android.a.p:
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLWindowSurfaceFactory -> com.badlogic.gdx.backends.android.a.q:
    javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object) -> a
    void destroySurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EglHelper -> com.badlogic.gdx.backends.android.a.r:
    java.lang.ref.WeakReference mGLSurfaceViewWeakRef -> f
    javax.microedition.khronos.egl.EGL10 mEgl -> a
    javax.microedition.khronos.egl.EGLDisplay mEglDisplay -> b
    javax.microedition.khronos.egl.EGLSurface mEglSurface -> c
    javax.microedition.khronos.egl.EGLConfig mEglConfig -> d
    javax.microedition.khronos.egl.EGLContext mEglContext -> e
    void start() -> a
    boolean createSurface() -> b
    javax.microedition.khronos.opengles.GL createGL() -> c
    int swap() -> d
    void destroySurface() -> e
    void destroySurfaceImp() -> g
    void finish() -> f
    void throwEglException(java.lang.String) -> a
    void throwEglException(java.lang.String,int) -> a
    void logEglErrorAsWarning(java.lang.String,java.lang.String,int) -> a
    java.lang.String getErrorString(int) -> a
    java.lang.String formatEglError(java.lang.String,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread -> com.badlogic.gdx.backends.android.a.s:
    boolean mShouldExit -> a
    boolean mExited -> b
    boolean mRequestPaused -> c
    boolean mPaused -> d
    boolean mHasSurface -> e
    boolean mSurfaceIsBad -> f
    boolean mWaitingForSurface -> g
    boolean mHaveEglContext -> h
    boolean mHaveEglSurface -> i
    boolean mFinishedCreatingEglSurface -> j
    boolean mShouldReleaseEglContext -> k
    int mWidth -> l
    int mHeight -> m
    int mRenderMode -> n
    boolean mRequestRender -> o
    boolean mRenderComplete -> p
    java.util.ArrayList mEventQueue -> q
    boolean mSizeChanged -> r
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EglHelper mEglHelper -> s
    java.lang.ref.WeakReference mGLSurfaceViewWeakRef -> t
    void run() -> run
    void stopEglSurfaceLocked() -> j
    void stopEglContextLocked() -> k
    void guardedRun() -> l
    boolean ableToDraw() -> a
    boolean readyToDraw() -> m
    void setRenderMode(int) -> a
    int getRenderMode() -> b
    void requestRender() -> c
    void surfaceCreated() -> d
    void surfaceDestroyed() -> e
    void onPause() -> f
    void onResume() -> g
    void onWindowResize(int,int) -> a
    void requestExitAndWait() -> h
    void requestReleaseEglContextLocked() -> i
    boolean access$1102(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread,boolean) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThreadManager -> com.badlogic.gdx.backends.android.a.t:
    java.lang.String TAG -> a
    boolean mGLESVersionCheckComplete -> b
    int mGLESVersion -> c
    boolean mGLESDriverCheckComplete -> d
    boolean mMultipleGLESContextsAllowed -> e
    boolean mLimitedGLESContexts -> f
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread mEglOwner -> g
    void threadExiting(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread) -> a
    boolean tryAcquireEglContextLocked(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread) -> b
    void releaseEglContextLocked(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread) -> c
    boolean shouldReleaseEGLContextWhenPausing() -> a
    boolean shouldTerminateEGLWhenPausing() -> b
    void checkGLDriver(javax.microedition.khronos.opengles.GL10) -> a
    void checkGLESVersion() -> c
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLWrapper -> com.badlogic.gdx.backends.android.a.u:
    javax.microedition.khronos.opengles.GL wrap(javax.microedition.khronos.opengles.GL) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$LogWriter -> com.badlogic.gdx.backends.android.a.v:
    java.lang.StringBuilder mBuilder -> a
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
    void flushBuilder() -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$SimpleEGLConfigChooser -> com.badlogic.gdx.backends.android.a.w:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 this$0 -> j
com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser -> com.badlogic.gdx.backends.android.a.x:
    int mRedSize -> a
    int mGreenSize -> b
    int mBlueSize -> c
    int mAlphaSize -> d
    int mDepthSize -> e
    int mStencilSize -> f
    int mNumSamples -> g
    int[] mConfigAttribs -> h
    int[] mValue -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy -> com.badlogic.gdx.backends.android.a.y:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension -> com.badlogic.gdx.backends.android.a.z:
    int width -> a
    int height -> b
com.badlogic.gdx.files.FileHandle -> com.badlogic.gdx.c.a:
    java.io.File file -> b
    com.badlogic.gdx.Files$FileType type -> c
    java.lang.String path() -> f
    java.lang.String name() -> g
    java.lang.String extension() -> h
    java.lang.String nameWithoutExtension() -> i
    java.lang.String pathWithoutExtension() -> j
    com.badlogic.gdx.Files$FileType type() -> k
    java.io.File file() -> e
    java.io.InputStream read() -> b
    java.io.BufferedInputStream read(int) -> a
    java.io.Reader reader(java.lang.String) -> c
    java.io.BufferedReader reader(int) -> b
    java.lang.String readString() -> l
    java.lang.String readString(java.lang.String) -> d
    byte[] readBytes() -> m
    int estimateLength() -> o
    java.io.Writer writer(boolean,java.lang.String) -> a
    void writeString(java.lang.String,boolean) -> a
    void writeString(java.lang.String,boolean,java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle parent() -> a
    void mkdirs() -> n
    boolean exists() -> c
    long length() -> d
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.badlogic.gdx.files.FileHandle$1 -> com.badlogic.gdx.c.b:
    int[] $SwitchMap$com$badlogic$gdx$Files$FileType -> a
com.badlogic.gdx.graphics.Camera -> com.badlogic.gdx.graphics.a:
    com.badlogic.gdx.math.Vector3 position -> a
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 up -> c
    com.badlogic.gdx.math.Matrix4 projection -> d
    com.badlogic.gdx.math.Matrix4 view -> e
    com.badlogic.gdx.math.Matrix4 combined -> f
    com.badlogic.gdx.math.Matrix4 invProjectionView -> g
    float near -> h
    float far -> i
    float viewportWidth -> j
    float viewportHeight -> k
    com.badlogic.gdx.math.Frustum frustum -> l
    com.badlogic.gdx.math.Vector3 tmpVec -> m
    com.badlogic.gdx.math.collision.Ray ray -> n
    void update() -> a
    com.badlogic.gdx.math.Vector3 unproject(com.badlogic.gdx.math.Vector3,float,float,float,float) -> a
    com.badlogic.gdx.math.Vector3 project(com.badlogic.gdx.math.Vector3,float,float,float,float) -> b
com.badlogic.gdx.graphics.Color -> com.badlogic.gdx.graphics.b:
    com.badlogic.gdx.graphics.Color CLEAR -> a
    com.badlogic.gdx.graphics.Color WHITE -> b
    com.badlogic.gdx.graphics.Color BLACK -> c
    com.badlogic.gdx.graphics.Color RED -> d
    com.badlogic.gdx.graphics.Color GREEN -> e
    com.badlogic.gdx.graphics.Color BLUE -> f
    com.badlogic.gdx.graphics.Color LIGHT_GRAY -> g
    com.badlogic.gdx.graphics.Color GRAY -> h
    com.badlogic.gdx.graphics.Color DARK_GRAY -> i
    com.badlogic.gdx.graphics.Color PINK -> j
    com.badlogic.gdx.graphics.Color ORANGE -> k
    com.badlogic.gdx.graphics.Color YELLOW -> l
    com.badlogic.gdx.graphics.Color MAGENTA -> m
    com.badlogic.gdx.graphics.Color CYAN -> n
    com.badlogic.gdx.graphics.Color OLIVE -> o
    com.badlogic.gdx.graphics.Color PURPLE -> p
    com.badlogic.gdx.graphics.Color MAROON -> q
    com.badlogic.gdx.graphics.Color TEAL -> r
    com.badlogic.gdx.graphics.Color NAVY -> s
    com.badlogic.gdx.graphics.Color tmp -> t
    float r -> u
    float g -> v
    float b -> w
    float a -> x
    com.badlogic.gdx.graphics.Color set(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.Color mul(com.badlogic.gdx.graphics.Color) -> b
    com.badlogic.gdx.graphics.Color clamp() -> a
    com.badlogic.gdx.graphics.Color set(float,float,float,float) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    float toFloatBits() -> b
    int toIntBits() -> c
    java.lang.String toString() -> toString
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String) -> a
    float toFloatBits(float,float,float,float) -> b
    int rgba8888(float,float,float,float) -> c
    void rgb888ToColor(com.badlogic.gdx.graphics.Color,int) -> a
    void rgba8888ToColor(com.badlogic.gdx.graphics.Color,int) -> b
com.badlogic.gdx.graphics.Colors -> com.badlogic.gdx.graphics.c:
    com.badlogic.gdx.utils.ObjectMap map -> a
    com.badlogic.gdx.graphics.Color get(java.lang.String) -> a
    void reset() -> a
com.badlogic.gdx.graphics.GL20 -> com.badlogic.gdx.graphics.d:
    void glBindTexture(int,int) -> glBindTexture
    void glBlendFunc(int,int) -> glBlendFunc
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthMask(boolean) -> glDepthMask
    void glDisable(int) -> glDisable
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glEnable(int) -> glEnable
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    java.lang.String glGetString(int) -> glGetString
    void glPixelStorei(int,int) -> glPixelStorei
    void glScissor(int,int,int,int) -> glScissor
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glViewport(int,int,int,int) -> glViewport
    void glAttachShader(int,int) -> glAttachShader
    void glBindBuffer(int,int) -> glBindBuffer
    void glBindFramebuffer(int,int) -> glBindFramebuffer
    void glBindRenderbuffer(int,int) -> glBindRenderbuffer
    void glBufferData(int,int,java.nio.Buffer,int) -> glBufferData
    void glBufferSubData(int,int,int,java.nio.Buffer) -> glBufferSubData
    int glCheckFramebufferStatus(int) -> glCheckFramebufferStatus
    void glCompileShader(int) -> glCompileShader
    int glCreateProgram() -> glCreateProgram
    int glCreateShader(int) -> glCreateShader
    void glDeleteBuffers(int,java.nio.IntBuffer) -> glDeleteBuffers
    void glDeleteFramebuffers(int,java.nio.IntBuffer) -> glDeleteFramebuffers
    void glDeleteProgram(int) -> glDeleteProgram
    void glDeleteRenderbuffers(int,java.nio.IntBuffer) -> glDeleteRenderbuffers
    void glDeleteShader(int) -> glDeleteShader
    void glDisableVertexAttribArray(int) -> glDisableVertexAttribArray
    void glDrawElements(int,int,int,int) -> glDrawElements
    void glEnableVertexAttribArray(int) -> glEnableVertexAttribArray
    void glFramebufferRenderbuffer(int,int,int,int) -> glFramebufferRenderbuffer
    void glFramebufferTexture2D(int,int,int,int,int) -> glFramebufferTexture2D
    void glGenBuffers(int,java.nio.IntBuffer) -> glGenBuffers
    void glGenerateMipmap(int) -> glGenerateMipmap
    void glGenFramebuffers(int,java.nio.IntBuffer) -> glGenFramebuffers
    void glGenRenderbuffers(int,java.nio.IntBuffer) -> glGenRenderbuffers
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveAttrib
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveUniform
    int glGetAttribLocation(int,java.lang.String) -> glGetAttribLocation
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> glGetProgramiv
    java.lang.String glGetProgramInfoLog(int) -> glGetProgramInfoLog
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> glGetShaderiv
    java.lang.String glGetShaderInfoLog(int) -> glGetShaderInfoLog
    int glGetUniformLocation(int,java.lang.String) -> glGetUniformLocation
    void glLinkProgram(int) -> glLinkProgram
    void glRenderbufferStorage(int,int,int,int) -> glRenderbufferStorage
    void glShaderSource(int,java.lang.String) -> glShaderSource
    void glUniform1i(int,int) -> glUniform1i
    void glUniformMatrix4fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix4fv
    void glUseProgram(int) -> glUseProgram
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> glVertexAttribPointer
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> glVertexAttribPointer
com.badlogic.gdx.graphics.GL30 -> com.badlogic.gdx.graphics.e:
com.badlogic.gdx.graphics.GLTexture -> com.badlogic.gdx.graphics.f:
    java.nio.IntBuffer buffer -> g
    int glTarget -> a
    int glHandle -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> f
    void bind() -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter getMinFilter() -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter getMagFilter() -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap getUWrap() -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap getVWrap() -> f
    int getTextureObjectHandle() -> g
    void setWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> a
    void setFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter) -> a
    void delete() -> h
    void dispose() -> c
    com.badlogic.gdx.graphics.TextureData createTextureData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap$Format,boolean) -> a
    int createGLHandle() -> i
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData) -> a
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData,int) -> a
com.badlogic.gdx.graphics.Mesh -> com.badlogic.gdx.graphics.g:
    java.util.Map meshes -> a
    com.badlogic.gdx.graphics.glutils.VertexData vertices -> b
    com.badlogic.gdx.graphics.glutils.IndexData indices -> c
    boolean autoBind -> d
    boolean isVertexArray -> e
    com.badlogic.gdx.math.Vector3 tmpV -> f
    com.badlogic.gdx.graphics.Mesh setVertices(float[],int,int) -> a
    com.badlogic.gdx.graphics.Mesh setIndices(short[]) -> a
    int getNumIndices() -> a
    int getNumVertices() -> b
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int,boolean) -> a
    void dispose() -> c
    com.badlogic.gdx.graphics.VertexAttribute getVertexAttribute(int) -> a
    com.badlogic.gdx.graphics.VertexAttributes getVertexAttributes() -> d
    java.nio.FloatBuffer getVerticesBuffer() -> e
    java.nio.ShortBuffer getIndicesBuffer() -> f
    void addManagedMesh(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Mesh) -> a
    void invalidateAllMeshes(com.badlogic.gdx.Application) -> a
    void clearAllMeshes(com.badlogic.gdx.Application) -> b
    java.lang.String getManagedStatus() -> g
com.badlogic.gdx.graphics.Mesh$VertexDataType -> com.badlogic.gdx.graphics.h:
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexArray -> a
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObject -> b
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectSubData -> c
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] $VALUES -> d
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] values() -> values
    com.badlogic.gdx.graphics.Mesh$VertexDataType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.OrthographicCamera -> com.badlogic.gdx.graphics.i:
    float zoom -> m
    com.badlogic.gdx.math.Vector3 tmp -> n
    void update() -> a
    void update(boolean) -> a
com.badlogic.gdx.graphics.Pixmap -> com.badlogic.gdx.graphics.j:
    com.badlogic.gdx.graphics.Pixmap$Blending blending -> c
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap pixmap -> a
    int color -> b
    boolean disposed -> d
    void setBlending(com.badlogic.gdx.graphics.Pixmap$Blending) -> a
    void setColor(float,float,float,float) -> a
    void fill() -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int,int,int) -> a
    int getWidth() -> b
    int getHeight() -> d
    void dispose() -> c
    int getGLFormat() -> e
    int getGLInternalFormat() -> f
    int getGLType() -> g
    java.nio.ByteBuffer getPixels() -> h
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> i
    com.badlogic.gdx.graphics.Pixmap$Blending getBlending() -> j
com.badlogic.gdx.graphics.Pixmap$Blending -> com.badlogic.gdx.graphics.k:
    com.badlogic.gdx.graphics.Pixmap$Blending None -> a
    com.badlogic.gdx.graphics.Pixmap$Blending SourceOver -> b
    com.badlogic.gdx.graphics.Pixmap$Blending[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Blending[] values() -> values
    com.badlogic.gdx.graphics.Pixmap$Blending valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.Pixmap$Format -> com.badlogic.gdx.graphics.l:
    com.badlogic.gdx.graphics.Pixmap$Format Alpha -> a
    com.badlogic.gdx.graphics.Pixmap$Format Intensity -> b
    com.badlogic.gdx.graphics.Pixmap$Format LuminanceAlpha -> c
    com.badlogic.gdx.graphics.Pixmap$Format RGB565 -> d
    com.badlogic.gdx.graphics.Pixmap$Format RGBA4444 -> e
    com.badlogic.gdx.graphics.Pixmap$Format RGB888 -> f
    com.badlogic.gdx.graphics.Pixmap$Format RGBA8888 -> g
    com.badlogic.gdx.graphics.Pixmap$Format[] $VALUES -> h
    com.badlogic.gdx.graphics.Pixmap$Format[] values() -> values
    com.badlogic.gdx.graphics.Pixmap$Format valueOf(java.lang.String) -> valueOf
    int toGdx2DPixmapFormat(com.badlogic.gdx.graphics.Pixmap$Format) -> a
    com.badlogic.gdx.graphics.Pixmap$Format fromGdx2DPixmapFormat(int) -> a
com.badlogic.gdx.graphics.PixmapIO -> com.badlogic.gdx.graphics.m:
    com.badlogic.gdx.graphics.Pixmap readCIM(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.PixmapIO$CIM -> com.badlogic.gdx.graphics.n:
    byte[] writeBuffer -> a
    byte[] readBuffer -> b
    com.badlogic.gdx.graphics.Pixmap read(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.Texture -> com.badlogic.gdx.graphics.o:
    com.badlogic.gdx.assets.AssetManager assetManager -> i
    java.util.Map managedTextures -> g
    com.badlogic.gdx.graphics.TextureData data -> h
    void load(com.badlogic.gdx.graphics.TextureData) -> a
    void reload() -> j
    int getWidth() -> k
    int getHeight() -> l
    com.badlogic.gdx.graphics.TextureData getTextureData() -> m
    boolean isManaged() -> n
    void dispose() -> c
    void addManagedTexture(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Texture) -> a
    void clearAllTextures(com.badlogic.gdx.Application) -> a
    void invalidateAllTextures(com.badlogic.gdx.Application) -> b
    void setAssetManager(com.badlogic.gdx.assets.AssetManager) -> a
    java.lang.String getManagedStatus() -> o
com.badlogic.gdx.graphics.Texture$1 -> com.badlogic.gdx.graphics.p:
    int val$refCount -> a
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.graphics.Texture$TextureFilter -> com.badlogic.gdx.graphics.q:
    com.badlogic.gdx.graphics.Texture$TextureFilter Nearest -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter Linear -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMap -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestNearest -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearNearest -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestLinear -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearLinear -> g
    int glEnum -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter[] $VALUES -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter[] values() -> values
    com.badlogic.gdx.graphics.Texture$TextureFilter valueOf(java.lang.String) -> valueOf
    boolean isMipMap() -> a
    int getGLEnum() -> b
com.badlogic.gdx.graphics.Texture$TextureWrap -> com.badlogic.gdx.graphics.r:
    com.badlogic.gdx.graphics.Texture$TextureWrap MirroredRepeat -> a
    com.badlogic.gdx.graphics.Texture$TextureWrap ClampToEdge -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap Repeat -> c
    int glEnum -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap[] $VALUES -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap[] values() -> values
    com.badlogic.gdx.graphics.Texture$TextureWrap valueOf(java.lang.String) -> valueOf
    int getGLEnum() -> a
com.badlogic.gdx.graphics.TextureData -> com.badlogic.gdx.graphics.s:
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    boolean isPrepared() -> b
    void prepare() -> c
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    void consumeCustomData(int) -> a
    int getWidth() -> f
    int getHeight() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    boolean useMipMaps() -> i
    boolean isManaged() -> j
com.badlogic.gdx.graphics.TextureData$TextureDataType -> com.badlogic.gdx.graphics.t:
    com.badlogic.gdx.graphics.TextureData$TextureDataType Pixmap -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType Custom -> b
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] $VALUES -> c
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] values() -> values
    com.badlogic.gdx.graphics.TextureData$TextureDataType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.VertexAttribute -> com.badlogic.gdx.graphics.u:
    int usage -> a
    int numComponents -> b
    boolean normalized -> c
    int type -> d
    int offset -> e
    java.lang.String alias -> f
    int unit -> g
    int usageIndex -> h
    com.badlogic.gdx.graphics.VertexAttribute Position() -> a
    com.badlogic.gdx.graphics.VertexAttribute TexCoords(int) -> a
    com.badlogic.gdx.graphics.VertexAttribute Normal() -> b
    com.badlogic.gdx.graphics.VertexAttribute Color() -> c
    com.badlogic.gdx.graphics.VertexAttribute ColorPacked() -> d
    com.badlogic.gdx.graphics.VertexAttribute ColorUnpacked() -> e
    com.badlogic.gdx.graphics.VertexAttribute Tangent() -> f
    com.badlogic.gdx.graphics.VertexAttribute Binormal() -> g
    com.badlogic.gdx.graphics.VertexAttribute BoneWeight(int) -> b
    boolean equals(java.lang.Object) -> equals
    boolean equals(com.badlogic.gdx.graphics.VertexAttribute) -> a
    int getKey() -> h
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.VertexAttributes -> com.badlogic.gdx.graphics.v:
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> b
    int vertexSize -> a
    long mask -> c
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable iterable -> d
    int calculateOffsets() -> b
    int size() -> a
    com.badlogic.gdx.graphics.VertexAttribute get(int) -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable -> com.badlogic.gdx.graphics.w:
    java.lang.Object[] array -> a
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator1 -> b
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator2 -> c
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator -> com.badlogic.gdx.graphics.x:
    java.lang.Object[] array -> c
    int index -> a
    boolean valid -> b
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.graphics.g2d.Animation -> com.badlogic.gdx.graphics.g2d.a:
    com.badlogic.gdx.graphics.g2d.TextureRegion[] keyFrames -> a
    float frameDuration -> b
    float animationDuration -> c
    int lastFrameNumber -> d
    float lastStateTime -> e
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode playMode -> f
    com.badlogic.gdx.graphics.g2d.TextureRegion getKeyFrame(float,boolean) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getKeyFrame(float) -> a
    int getKeyFrameIndex(float) -> b
    com.badlogic.gdx.graphics.g2d.TextureRegion[] getKeyFrames() -> a
    boolean isAnimationFinished(float) -> c
com.badlogic.gdx.graphics.g2d.Animation$1 -> com.badlogic.gdx.graphics.g2d.b:
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$Animation$PlayMode -> a
com.badlogic.gdx.graphics.g2d.Animation$PlayMode -> com.badlogic.gdx.graphics.g2d.c:
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode NORMAL -> a
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode REVERSED -> b
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode LOOP -> c
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode LOOP_REVERSED -> d
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode LOOP_PINGPONG -> e
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode LOOP_RANDOM -> f
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode[] $VALUES -> g
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode[] values() -> values
    com.badlogic.gdx.graphics.g2d.Animation$PlayMode valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.Batch -> com.badlogic.gdx.graphics.g2d.d:
    void begin() -> a
    void end() -> b
    void setColor(float,float,float,float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> d
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> a
    void flush() -> e
    void setBlendFunction(int,int) -> a
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> f
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
com.badlogic.gdx.graphics.g2d.BitmapFont -> com.badlogic.gdx.graphics.g2d.e:
    char[] xChars -> a
    char[] capChars -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion[] regions -> d
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> f
    boolean flipped -> g
    boolean integer -> h
    boolean ownsTexture -> i
    boolean markupEnabled -> e
    void load(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence,int,int) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getMultiLineBounds(java.lang.CharSequence) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getMultiLineBounds(java.lang.CharSequence,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getWrappedBounds(java.lang.CharSequence,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getWrappedBounds(java.lang.CharSequence,float,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    int computeVisibleGlyphs(java.lang.CharSequence,int,int,float) -> a
    void setScale(float,float) -> a
    void setScale(float) -> a
    float getScaleX() -> a
    float getScaleY() -> b
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> d
    com.badlogic.gdx.graphics.g2d.TextureRegion[] getRegions() -> e
    float getCapHeight() -> f
    float getDescent() -> g
    boolean isFlipped() -> h
    void dispose() -> c
    boolean usesIntegerPositions() -> i
    int indexOf(java.lang.CharSequence,char,int) -> a
    boolean isWhitespace(char) -> a
com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData -> com.badlogic.gdx.graphics.g2d.f:
    java.lang.String imagePath -> a
    java.lang.String[] imagePaths -> b
    com.badlogic.gdx.files.FileHandle fontFile -> c
    boolean flipped -> d
    float lineHeight -> e
    float capHeight -> f
    float ascent -> g
    float descent -> h
    float down -> i
    float scaleX -> j
    float scaleY -> k
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph[][] glyphs -> l
    float spaceWidth -> m
    float xHeight -> n
    void setGlyph(int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getFirstGlyph() -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getGlyph(char) -> a
    java.lang.String getImagePath(int) -> a
    java.lang.String[] getImagePaths() -> b
com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph -> com.badlogic.gdx.graphics.g2d.g:
    int id -> a
    int srcX -> b
    int srcY -> c
    int width -> d
    int height -> e
    float u -> f
    float v -> g
    float u2 -> h
    float v2 -> i
    int xoffset -> j
    int yoffset -> k
    int xadvance -> l
    byte[][] kerning -> m
    int page -> n
    int getKerning(char) -> a
    void setKerning(int,int) -> a
com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment -> com.badlogic.gdx.graphics.g2d.h:
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment LEFT -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment CENTER -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment RIGHT -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment[] $VALUES -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment[] values() -> values
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds -> com.badlogic.gdx.graphics.g2d.i:
    float width -> a
    float height -> b
    void set(com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
com.badlogic.gdx.graphics.g2d.BitmapFontCache -> com.badlogic.gdx.graphics.g2d.j:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    float[][] vertexData -> b
    int[] idx -> c
    int[] tmpGlyphCount -> d
    float x -> e
    float y -> f
    float color -> g
    float previousColor -> h
    com.badlogic.gdx.graphics.Color tempColor -> i
    com.badlogic.gdx.graphics.Color hexColor -> j
    com.badlogic.gdx.utils.StringBuilder colorBuffer -> k
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds textBounds -> l
    boolean integer -> m
    int glyphCount -> n
    com.badlogic.gdx.utils.IntArray[] glyphIndices -> o
    void setPosition(float,float) -> a
    void translate(float,float) -> b
    void setColors(com.badlogic.gdx.graphics.Color) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void clear() -> a
    int countGlyphs(java.lang.CharSequence,int,int) -> a
    void requireSequence(java.lang.CharSequence,int,int) -> b
    void require(int,int) -> a
    int parseAndSetColor(java.lang.CharSequence,int,int) -> c
    float addToCache(java.lang.CharSequence,float,float,int,int) -> a
    void addGlyph(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,float,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setMultiLineText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addMultiLineText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setWrappedText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addWrappedText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds() -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont() -> c
    void setUseIntegerPositions(boolean) -> a
com.badlogic.gdx.graphics.g2d.Gdx2DPixmap -> com.badlogic.gdx.graphics.g2d.Gdx2DPixmap:
    long basePtr -> a
    int width -> b
    int height -> c
    int format -> d
    java.nio.ByteBuffer pixelPtr -> e
    long[] nativeData -> f
    void convert(int) -> b
    void dispose() -> c
    void clear(int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int,int,int) -> a
    java.nio.ByteBuffer getPixels() -> a
    int getHeight() -> b
    int getWidth() -> d
    int getFormat() -> e
    int getGLInternalFormat() -> f
    int getGLFormat() -> g
    int getGLType() -> h
    java.nio.ByteBuffer load(long[],byte[],int,int) -> load
    java.nio.ByteBuffer newPixmap(long[],int,int,int) -> newPixmap
    void free(long) -> free
    void clear(long,int) -> clear
    void drawPixmap(long,long,int,int,int,int,int,int,int,int) -> drawPixmap
    void setBlend(int) -> setBlend
    void setScale(int) -> setScale
    java.lang.String getFailureReason() -> getFailureReason
com.badlogic.gdx.graphics.g2d.NinePatch -> com.badlogic.gdx.graphics.g2d.k:
    com.badlogic.gdx.graphics.Color tmpDrawColor -> a
    com.badlogic.gdx.graphics.Texture texture -> b
    int bottomLeft -> c
    int bottomCenter -> d
    int bottomRight -> e
    int middleLeft -> f
    int middleCenter -> g
    int middleRight -> h
    int topLeft -> i
    int topCenter -> j
    int topRight -> k
    float leftWidth -> l
    float rightWidth -> m
    float middleWidth -> n
    float middleHeight -> o
    float topHeight -> p
    float bottomHeight -> q
    float[] vertices -> r
    int idx -> s
    com.badlogic.gdx.graphics.Color color -> t
    int padLeft -> u
    int padRight -> v
    int padTop -> w
    int padBottom -> x
    void load(com.badlogic.gdx.graphics.g2d.TextureRegion[]) -> a
    int add(com.badlogic.gdx.graphics.g2d.TextureRegion,float,boolean,boolean) -> a
    void set(int,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getLeftWidth() -> a
    float getRightWidth() -> b
    float getTopHeight() -> c
    float getBottomHeight() -> d
    float getTotalWidth() -> e
    float getTotalHeight() -> f
    void setPadding(int,int,int,int) -> a
    float getPadLeft() -> g
    float getPadRight() -> h
    float getPadTop() -> i
    float getPadBottom() -> j
com.badlogic.gdx.graphics.g2d.ParticleEffect -> com.badlogic.gdx.graphics.g2d.l:
    com.badlogic.gdx.utils.Array emitters -> a
    boolean ownsTexture -> b
    void start() -> a
    void update(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void allowCompletion() -> b
    boolean isComplete() -> d
    void setPosition(float,float) -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle) -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String) -> a
    void loadEmitters(com.badlogic.gdx.files.FileHandle) -> a
    void loadEmitterImages(com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String) -> a
    void loadEmitterImages(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.graphics.Texture loadTexture(com.badlogic.gdx.files.FileHandle) -> c
    void dispose() -> c
com.badlogic.gdx.graphics.g2d.ParticleEmitter -> com.badlogic.gdx.graphics.g2d.m:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue delayValue -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue lifeOffsetValue -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue durationValue -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue lifeValue -> f
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue emissionValue -> g
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue scaleValue -> h
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue rotationValue -> i
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue velocityValue -> j
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue angleValue -> k
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue windValue -> l
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue gravityValue -> m
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue transparencyValue -> n
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue tintValue -> o
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue xOffsetValue -> p
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue yOffsetValue -> q
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnWidthValue -> r
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnHeightValue -> s
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue spawnShapeValue -> t
    float accumulator -> u
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> v
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle[] particles -> w
    int minParticleCount -> x
    int maxParticleCount -> y
    float x -> z
    float y -> A
    java.lang.String name -> B
    java.lang.String imagePath -> C
    int activeCount -> D
    boolean[] active -> E
    boolean firstUpdate -> F
    boolean flipX -> G
    boolean flipY -> H
    int updateFlags -> I
    boolean allowCompletion -> J
    int emission -> K
    int emissionDiff -> L
    int emissionDelta -> M
    int lifeOffset -> N
    int lifeOffsetDiff -> O
    int life -> P
    int lifeDiff -> Q
    float spawnWidth -> R
    float spawnWidthDiff -> S
    float spawnHeight -> T
    float spawnHeightDiff -> U
    float duration -> a
    float durationTimer -> b
    float delay -> V
    float delayTimer -> W
    boolean attached -> X
    boolean continuous -> Y
    boolean aligned -> Z
    boolean behind -> aa
    boolean additive -> ab
    boolean premultipliedAlpha -> ac
    void initialize() -> g
    void setMaxParticleCount(int) -> a
    void addParticle() -> a
    void addParticles(int) -> b
    void update(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void start() -> b
    void restart() -> h
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle newParticle(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    void activateParticle(int) -> d
    boolean updateParticle(com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle,float,int) -> a
    void setPosition(float,float) -> a
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> b
    void allowCompletion() -> c
    com.badlogic.gdx.graphics.g2d.Sprite getSprite() -> d
    void setMinParticleCount(int) -> c
    boolean isComplete() -> e
    java.lang.String getImagePath() -> f
    void setImagePath(java.lang.String) -> a
    void load(java.io.BufferedReader) -> a
    java.lang.String readString(java.lang.String) -> b
    java.lang.String readString(java.io.BufferedReader,java.lang.String) -> a
    boolean readBoolean(java.lang.String) -> c
    boolean readBoolean(java.io.BufferedReader,java.lang.String) -> b
    int readInt(java.io.BufferedReader,java.lang.String) -> c
    float readFloat(java.io.BufferedReader,java.lang.String) -> d
com.badlogic.gdx.graphics.g2d.ParticleEmitter$1 -> com.badlogic.gdx.graphics.g2d.n:
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$ParticleEmitter$SpawnEllipseSide -> a
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$ParticleEmitter$SpawnShape -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue -> com.badlogic.gdx.graphics.g2d.o:
    float[] temp -> d
    float[] colors -> e
    float[] timeline -> a
    float[] getColor(float) -> a
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle -> com.badlogic.gdx.graphics.g2d.p:
    int life -> a
    int currentLife -> b
    float scale -> c
    float scaleDiff -> d
    float rotation -> e
    float rotationDiff -> f
    float velocity -> g
    float velocityDiff -> h
    float angle -> i
    float angleDiff -> j
    float angleCos -> k
    float angleSin -> l
    float transparency -> m
    float transparencyDiff -> n
    float wind -> o
    float windDiff -> p
    float gravity -> q
    float gravityDiff -> r
    float[] tint -> s
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ParticleValue -> com.badlogic.gdx.graphics.g2d.q:
    boolean active -> b
    boolean alwaysActive -> c
    void setAlwaysActive(boolean) -> a
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue -> com.badlogic.gdx.graphics.g2d.r:
    float lowMin -> a
    float lowMax -> d
    float newLowValue() -> a
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue -> com.badlogic.gdx.graphics.g2d.s:
    float[] scaling -> d
    float[] timeline -> a
    float highMin -> e
    float highMax -> f
    boolean relative -> g
    float newHighValue() -> b
    boolean isRelative() -> c
    float getScale(float) -> a
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide -> com.badlogic.gdx.graphics.g2d.t:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide both -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide top -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide bottom -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide[] $VALUES -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide[] values() -> values
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape -> com.badlogic.gdx.graphics.g2d.u:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape point -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape line -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape square -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape ellipse -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape[] $VALUES -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape[] values() -> values
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue -> com.badlogic.gdx.graphics.g2d.v:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape shape -> a
    boolean edges -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide side -> e
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.PolygonRegion -> com.badlogic.gdx.graphics.g2d.w:
    float[] textureCoords -> a
    float[] vertices -> b
    short[] triangles -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> d
com.badlogic.gdx.graphics.g2d.PolygonRegionLoader -> com.badlogic.gdx.graphics.g2d.x:
    com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters defaultParameters -> a
    com.badlogic.gdx.math.EarClippingTriangulator triangulator -> b
    com.badlogic.gdx.graphics.g2d.PolygonRegion load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters) -> a
    com.badlogic.gdx.graphics.g2d.PolygonRegion load(com.badlogic.gdx.graphics.g2d.TextureRegion,com.badlogic.gdx.files.FileHandle) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters -> com.badlogic.gdx.graphics.g2d.y:
    java.lang.String texturePrefix -> b
    int readerBuffer -> c
    java.lang.String[] textureExtensions -> d
com.badlogic.gdx.graphics.g2d.Sprite -> com.badlogic.gdx.graphics.g2d.z:
    float[] vertices -> t
    com.badlogic.gdx.graphics.Color color -> a
    float x -> b
    float y -> c
    float width -> u
    float height -> v
    float originX -> d
    float originY -> e
    float rotation -> f
    float scaleX -> g
    float scaleY -> h
    boolean dirty -> i
    void set(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    void setBounds(float,float,float,float) -> a
    void setSize(float,float) -> a
    void translate(float,float) -> b
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> b
    void setOrigin(float,float) -> c
    void setRotation(float) -> a
    void rotate90(boolean) -> a
    void setScale(float) -> b
    void setScale(float,float) -> d
    float[] getVertices() -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    float getX() -> b
    float getY() -> c
    float getWidth() -> d
    float getHeight() -> e
    float getOriginX() -> f
    float getOriginY() -> g
    com.badlogic.gdx.graphics.Color getColor() -> h
    void setRegion(float,float,float,float) -> c
    void flip(boolean,boolean) -> a
com.badlogic.gdx.graphics.g2d.SpriteBatch -> com.badlogic.gdx.graphics.g2d.aa:
    com.badlogic.gdx.graphics.Mesh mesh -> e
    float[] vertices -> f
    int idx -> g
    com.badlogic.gdx.graphics.Texture lastTexture -> h
    float invTexWidth -> i
    float invTexHeight -> j
    boolean drawing -> k
    com.badlogic.gdx.math.Matrix4 transformMatrix -> l
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> m
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> n
    boolean blendingDisabled -> o
    int blendSrcFunc -> p
    int blendDstFunc -> q
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> r
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> s
    boolean ownsShader -> t
    float color -> a
    com.badlogic.gdx.graphics.Color tempColor -> u
    int renderCalls -> b
    int totalRenderCalls -> c
    int maxSpritesInBatch -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> g
    void begin() -> a
    void end() -> b
    void setColor(float,float,float,float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> d
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float,float,int,int,int,int,boolean,boolean) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> a
    void flush() -> e
    void setBlendFunction(int,int) -> a
    void dispose() -> c
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> f
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
    void setupMatrices() -> i
    void switchTexture(com.badlogic.gdx.graphics.Texture) -> a
    boolean isBlendingEnabled() -> h
com.badlogic.gdx.graphics.g2d.TextureAtlas -> com.badlogic.gdx.graphics.g2d.ab:
    java.lang.String[] tuple -> a
    com.badlogic.gdx.utils.ObjectSet textures -> c
    com.badlogic.gdx.utils.Array regions -> d
    java.util.Comparator indexComparator -> b
    void load(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData) -> a
    com.badlogic.gdx.utils.Array getRegions() -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion findRegion(java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion findRegion(java.lang.String,int) -> a
    com.badlogic.gdx.utils.Array findRegions(java.lang.String) -> b
    com.badlogic.gdx.graphics.g2d.Sprite createSprite(java.lang.String) -> c
    com.badlogic.gdx.graphics.g2d.Sprite newSprite(com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion) -> a
    com.badlogic.gdx.utils.ObjectSet getTextures() -> b
    void dispose() -> c
    java.lang.String readValue(java.io.BufferedReader) -> a
    int readTuple(java.io.BufferedReader) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$1 -> com.badlogic.gdx.graphics.g2d.ac:
    int compare(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region,com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion -> com.badlogic.gdx.graphics.g2d.ad:
    int index -> a
    java.lang.String name -> b
    float offsetX -> c
    float offsetY -> d
    int packedWidth -> e
    int packedHeight -> f
    int originalWidth -> g
    int originalHeight -> h
    boolean rotate -> i
    int[] splits -> j
    int[] pads -> k
    void flip(boolean,boolean) -> a
    float getRotatedPackedWidth() -> a
    float getRotatedPackedHeight() -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasSprite -> com.badlogic.gdx.graphics.g2d.ae:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion region -> a
    float originalOffsetX -> b
    float originalOffsetY -> c
    void setBounds(float,float,float,float) -> a
    void setSize(float,float) -> a
    void setOrigin(float,float) -> c
    void flip(boolean,boolean) -> a
    void rotate90(boolean) -> a
    float getX() -> b
    float getY() -> c
    float getOriginX() -> f
    float getOriginY() -> g
    float getWidth() -> d
    float getHeight() -> e
    float getWidthRatio() -> i
    float getHeightRatio() -> j
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData -> com.badlogic.gdx.graphics.g2d.af:
    com.badlogic.gdx.utils.Array pages -> a
    com.badlogic.gdx.utils.Array regions -> b
    com.badlogic.gdx.utils.Array getPages() -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page -> com.badlogic.gdx.graphics.g2d.ag:
    com.badlogic.gdx.files.FileHandle textureFile -> a
    com.badlogic.gdx.graphics.Texture texture -> b
    float width -> c
    float height -> d
    boolean useMipMaps -> e
    com.badlogic.gdx.graphics.Pixmap$Format format -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> h
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> i
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> j
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region -> com.badlogic.gdx.graphics.g2d.ah:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page page -> a
    int index -> b
    java.lang.String name -> c
    float offsetX -> d
    float offsetY -> e
    int originalWidth -> f
    int originalHeight -> g
    boolean rotate -> h
    int left -> i
    int top -> j
    int width -> k
    int height -> l
    boolean flip -> m
    int[] splits -> n
    int[] pads -> o
com.badlogic.gdx.graphics.g2d.TextureRegion -> com.badlogic.gdx.graphics.g2d.ai:
    com.badlogic.gdx.graphics.Texture texture -> w
    float u -> x
    float v -> y
    float u2 -> z
    float v2 -> A
    int regionWidth -> B
    int regionHeight -> C
    void setRegion(int,int,int,int) -> a
    void setRegion(float,float,float,float) -> c
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,int,int,int,int) -> a
    com.badlogic.gdx.graphics.Texture getTexture() -> k
    void setTexture(com.badlogic.gdx.graphics.Texture) -> a
    float getU() -> l
    float getV() -> m
    float getU2() -> n
    float getV2() -> o
    int getRegionX() -> p
    int getRegionY() -> q
    int getRegionWidth() -> r
    int getRegionHeight() -> s
    void flip(boolean,boolean) -> a
com.badlogic.gdx.graphics.g3d.Attribute -> com.badlogic.gdx.graphics.a.a:
    com.badlogic.gdx.utils.Array types -> b
    long type -> a
    long getAttributeType(java.lang.String) -> a
    java.lang.String getAttributeAlias(long) -> a
    long register(java.lang.String) -> b
    boolean equals(com.badlogic.gdx.graphics.g3d.Attribute) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.graphics.g3d.Attributes -> com.badlogic.gdx.graphics.a.b:
    long mask -> a
    com.badlogic.gdx.utils.Array attributes -> b
    boolean sorted -> c
    void sort() -> a
    void enable(long) -> c
    void set(com.badlogic.gdx.graphics.g3d.Attribute) -> a
    boolean has(long) -> a
    int indexOf(long) -> b
    int compare(com.badlogic.gdx.graphics.g3d.Attribute,com.badlogic.gdx.graphics.g3d.Attribute) -> a
    java.util.Iterator iterator() -> iterator
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    int compare(java.lang.Object,java.lang.Object) -> compare
com.badlogic.gdx.graphics.g3d.Material -> com.badlogic.gdx.graphics.a.c:
    int counter -> e
    java.lang.String id -> d
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.Model -> com.badlogic.gdx.graphics.a.d:
    com.badlogic.gdx.utils.Array materials -> a
    com.badlogic.gdx.utils.Array nodes -> b
    com.badlogic.gdx.utils.Array animations -> c
    com.badlogic.gdx.utils.Array meshes -> d
    com.badlogic.gdx.utils.Array meshParts -> e
    com.badlogic.gdx.utils.Array disposables -> f
    com.badlogic.gdx.utils.ObjectMap nodePartBones -> g
    void load(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    void loadAnimations(java.lang.Iterable) -> a
    void loadNodes(java.lang.Iterable) -> b
    com.badlogic.gdx.graphics.g3d.model.Node loadNode(com.badlogic.gdx.graphics.g3d.model.Node,com.badlogic.gdx.graphics.g3d.model.data.ModelNode) -> a
    void loadMeshes(java.lang.Iterable) -> c
    void convertMesh(com.badlogic.gdx.graphics.g3d.model.data.ModelMesh) -> a
    void loadMaterials(java.lang.Iterable,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    com.badlogic.gdx.graphics.g3d.Material convertMaterial(com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    java.lang.Iterable getManagedDisposables() -> a
    void dispose() -> c
    void calculateTransforms() -> b
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String) -> a
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String,boolean,boolean) -> a
com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute -> com.badlogic.gdx.graphics.a.a.a:
    long Type -> b
    boolean blended -> c
    int sourceFunction -> d
    int destFunction -> e
    float opacity -> f
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute -> com.badlogic.gdx.graphics.a.a.b:
    long Diffuse -> b
    long Specular -> c
    long Ambient -> d
    long Emissive -> e
    long Reflection -> f
    long AmbientLight -> g
    long Fog -> h
    long Mask -> i
    com.badlogic.gdx.graphics.Color color -> j
    boolean is(long) -> b
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute -> com.badlogic.gdx.graphics.a.a.c:
    long Shininess -> b
    long AlphaTest -> c
    float value -> d
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute -> com.badlogic.gdx.graphics.a.a.d:
    long Diffuse -> b
    long Specular -> c
    long Bump -> d
    long Normal -> e
    long Mask -> f
    com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor textureDescription -> g
    boolean is(long) -> b
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader -> com.badlogic.gdx.graphics.a.b.a:
    com.badlogic.gdx.utils.BaseJsonReader reader -> c
    com.badlogic.gdx.math.Quaternion tempQ -> d
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData parseModel(com.badlogic.gdx.files.FileHandle) -> a
    void parseMeshes(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> a
    int parseType(java.lang.String) -> b
    com.badlogic.gdx.graphics.VertexAttribute[] parseAttributes(com.badlogic.gdx.utils.JsonValue) -> a
    void parseMaterials(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue,java.lang.String) -> a
    int parseTextureUsage(java.lang.String) -> c
    com.badlogic.gdx.graphics.Color parseColor(com.badlogic.gdx.utils.JsonValue) -> b
    com.badlogic.gdx.math.Vector2 readVector2(com.badlogic.gdx.utils.JsonValue,float,float) -> a
    com.badlogic.gdx.utils.Array parseNodes(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> b
    com.badlogic.gdx.graphics.g3d.model.data.ModelNode parseNodesRecursively(com.badlogic.gdx.utils.JsonValue) -> c
    void parseAnimations(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> c
com.badlogic.gdx.graphics.g3d.loader.MtlLoader -> com.badlogic.gdx.graphics.a.b.b:
    com.badlogic.gdx.utils.Array materials -> a
    void load(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial getMaterial(java.lang.String) -> a
com.badlogic.gdx.graphics.g3d.loader.ObjLoader -> com.badlogic.gdx.graphics.a.b.c:
    boolean logWarning -> c
    com.badlogic.gdx.utils.FloatArray verts -> d
    com.badlogic.gdx.utils.FloatArray norms -> e
    com.badlogic.gdx.utils.FloatArray uvs -> f
    com.badlogic.gdx.utils.Array groups -> g
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.loader.ObjLoader$ObjLoaderParameters) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,boolean) -> a
    com.badlogic.gdx.graphics.g3d.loader.ObjLoader$Group setActiveGroup(java.lang.String) -> b
    int getIndex(java.lang.String,int) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
com.badlogic.gdx.graphics.g3d.loader.ObjLoader$Group -> com.badlogic.gdx.graphics.a.b.d:
    java.lang.String name -> a
    java.lang.String materialName -> b
    com.badlogic.gdx.utils.Array faces -> c
    int numFaces -> d
    boolean hasNorms -> e
    boolean hasUVs -> f
    com.badlogic.gdx.graphics.g3d.Material mat -> g
    com.badlogic.gdx.graphics.g3d.loader.ObjLoader this$0 -> h
com.badlogic.gdx.graphics.g3d.loader.ObjLoader$ObjLoaderParameters -> com.badlogic.gdx.graphics.a.b.e:
    boolean flipV -> c
com.badlogic.gdx.graphics.g3d.model.Animation -> com.badlogic.gdx.graphics.a.c.a:
    java.lang.String id -> a
    float duration -> b
    com.badlogic.gdx.utils.Array nodeAnimations -> c
com.badlogic.gdx.graphics.g3d.model.MeshPart -> com.badlogic.gdx.graphics.a.c.b:
    java.lang.String id -> a
    int primitiveType -> b
    int indexOffset -> c
    int numVertices -> d
    com.badlogic.gdx.graphics.Mesh mesh -> e
    boolean equals(com.badlogic.gdx.graphics.g3d.model.MeshPart) -> a
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.graphics.g3d.model.Node -> com.badlogic.gdx.graphics.a.c.c:
    java.lang.String id -> a
    com.badlogic.gdx.graphics.g3d.model.Node parent -> b
    com.badlogic.gdx.utils.Array children -> c
    boolean isAnimated -> d
    com.badlogic.gdx.math.Vector3 translation -> e
    com.badlogic.gdx.math.Quaternion rotation -> f
    com.badlogic.gdx.math.Vector3 scale -> g
    com.badlogic.gdx.math.Matrix4 localTransform -> h
    com.badlogic.gdx.math.Matrix4 globalTransform -> i
    com.badlogic.gdx.utils.Array parts -> j
    com.badlogic.gdx.math.Matrix4 calculateLocalTransform() -> a
    com.badlogic.gdx.math.Matrix4 calculateWorldTransform() -> b
    void calculateTransforms(boolean) -> a
    void calculateBoneTransforms(boolean) -> b
    com.badlogic.gdx.graphics.g3d.model.Node getNode(com.badlogic.gdx.utils.Array,java.lang.String,boolean,boolean) -> a
com.badlogic.gdx.graphics.g3d.model.NodeAnimation -> com.badlogic.gdx.graphics.a.c.d:
    com.badlogic.gdx.graphics.g3d.model.Node node -> a
    com.badlogic.gdx.utils.Array keyframes -> b
com.badlogic.gdx.graphics.g3d.model.NodeKeyframe -> com.badlogic.gdx.graphics.a.c.e:
    float keytime -> a
    com.badlogic.gdx.math.Vector3 translation -> b
    com.badlogic.gdx.math.Vector3 scale -> c
    com.badlogic.gdx.math.Quaternion rotation -> d
com.badlogic.gdx.graphics.g3d.model.NodePart -> com.badlogic.gdx.graphics.a.c.f:
    com.badlogic.gdx.graphics.g3d.model.MeshPart meshPart -> a
    com.badlogic.gdx.graphics.g3d.Material material -> b
    com.badlogic.gdx.utils.ArrayMap invBoneBindTransforms -> c
    com.badlogic.gdx.math.Matrix4[] bones -> d
    boolean enabled -> e
com.badlogic.gdx.graphics.g3d.model.data.ModelAnimation -> com.badlogic.gdx.graphics.a.c.a.a:
    java.lang.String id -> a
    com.badlogic.gdx.utils.Array nodeAnimations -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelData -> com.badlogic.gdx.graphics.a.c.a.b:
    java.lang.String id -> a
    short[] version -> b
    com.badlogic.gdx.utils.Array meshes -> c
    com.badlogic.gdx.utils.Array materials -> d
    com.badlogic.gdx.utils.Array nodes -> e
    com.badlogic.gdx.utils.Array animations -> f
com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial -> com.badlogic.gdx.graphics.a.c.a.c:
    java.lang.String id -> a
    com.badlogic.gdx.graphics.Color ambient -> b
    com.badlogic.gdx.graphics.Color diffuse -> c
    com.badlogic.gdx.graphics.Color specular -> d
    com.badlogic.gdx.graphics.Color emissive -> e
    com.badlogic.gdx.graphics.Color reflection -> f
    float shininess -> g
    float opacity -> h
    com.badlogic.gdx.utils.Array textures -> i
com.badlogic.gdx.graphics.g3d.model.data.ModelMesh -> com.badlogic.gdx.graphics.a.c.a.d:
    java.lang.String id -> a
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> b
    float[] vertices -> c
    com.badlogic.gdx.graphics.g3d.model.data.ModelMeshPart[] parts -> d
com.badlogic.gdx.graphics.g3d.model.data.ModelMeshPart -> com.badlogic.gdx.graphics.a.c.a.e:
    java.lang.String id -> a
    short[] indices -> b
    int primitiveType -> c
com.badlogic.gdx.graphics.g3d.model.data.ModelNode -> com.badlogic.gdx.graphics.a.c.a.f:
    java.lang.String id -> a
    int boneId -> b
    com.badlogic.gdx.math.Vector3 translation -> c
    com.badlogic.gdx.math.Quaternion rotation -> d
    com.badlogic.gdx.math.Vector3 scale -> e
    java.lang.String meshId -> f
    com.badlogic.gdx.graphics.g3d.model.data.ModelNodePart[] parts -> g
    com.badlogic.gdx.graphics.g3d.model.data.ModelNode[] children -> h
com.badlogic.gdx.graphics.g3d.model.data.ModelNodeAnimation -> com.badlogic.gdx.graphics.a.c.a.g:
    java.lang.String nodeId -> a
    com.badlogic.gdx.utils.Array keyframes -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelNodeKeyframe -> com.badlogic.gdx.graphics.a.c.a.h:
    float keytime -> a
    com.badlogic.gdx.math.Vector3 translation -> b
    com.badlogic.gdx.math.Vector3 scale -> c
    com.badlogic.gdx.math.Quaternion rotation -> d
com.badlogic.gdx.graphics.g3d.model.data.ModelNodePart -> com.badlogic.gdx.graphics.a.c.a.i:
    java.lang.String materialId -> a
    java.lang.String meshPartId -> b
    com.badlogic.gdx.utils.ArrayMap bones -> c
com.badlogic.gdx.graphics.g3d.model.data.ModelTexture -> com.badlogic.gdx.graphics.a.c.a.j:
    java.lang.String id -> a
    java.lang.String fileName -> b
    com.badlogic.gdx.math.Vector2 uvTranslation -> c
    com.badlogic.gdx.math.Vector2 uvScaling -> d
    int usage -> e
com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor -> com.badlogic.gdx.graphics.a.d.a:
    com.badlogic.gdx.graphics.GLTexture texture -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> e
    void set(com.badlogic.gdx.graphics.GLTexture,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> a
    void set(com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor) -> a
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.graphics.g3d.utils.TextureProvider -> com.badlogic.gdx.graphics.a.d.b:
    com.badlogic.gdx.graphics.Texture load(java.lang.String) -> a
com.badlogic.gdx.graphics.g3d.utils.TextureProvider$AssetTextureProvider -> com.badlogic.gdx.graphics.a.d.c:
    com.badlogic.gdx.assets.AssetManager assetManager -> a
    com.badlogic.gdx.graphics.Texture load(java.lang.String) -> a
com.badlogic.gdx.graphics.glutils.ETC1 -> com.badlogic.gdx.graphics.glutils.ETC1:
    int PKM_HEADER_SIZE -> a
    int ETC1_RGB8_OES -> b
    int getPixelSize(com.badlogic.gdx.graphics.Pixmap$Format) -> a
    com.badlogic.gdx.graphics.Pixmap decodeImage(com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data,com.badlogic.gdx.graphics.Pixmap$Format) -> a
    int getWidthPKM(java.nio.ByteBuffer,int) -> getWidthPKM
    int getHeightPKM(java.nio.ByteBuffer,int) -> getHeightPKM
    boolean isValidPKM(java.nio.ByteBuffer,int) -> isValidPKM
    void decodeImage(java.nio.ByteBuffer,int,java.nio.ByteBuffer,int,int,int,int) -> decodeImage
com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data -> com.badlogic.gdx.graphics.glutils.a:
    int width -> a
    int height -> b
    java.nio.ByteBuffer compressedData -> c
    int dataOffset -> d
    void checkNPOT() -> b
    boolean hasPKMHeader() -> a
    void dispose() -> c
    java.lang.String toString() -> toString
com.badlogic.gdx.graphics.glutils.ETC1TextureData -> com.badlogic.gdx.graphics.glutils.b:
    com.badlogic.gdx.files.FileHandle file -> a
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data data -> b
    boolean useMipMaps -> c
    int width -> d
    int height -> e
    boolean isPrepared -> f
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    boolean isPrepared() -> b
    void prepare() -> c
    void consumeCustomData(int) -> a
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    int getWidth() -> f
    int getHeight() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    boolean useMipMaps() -> i
    boolean isManaged() -> j
com.badlogic.gdx.graphics.glutils.FileTextureData -> com.badlogic.gdx.graphics.glutils.c:
    boolean copyToPOT -> a
    com.badlogic.gdx.files.FileHandle file -> b
    int width -> c
    int height -> d
    com.badlogic.gdx.graphics.Pixmap$Format format -> e
    com.badlogic.gdx.graphics.Pixmap pixmap -> f
    boolean useMipMaps -> g
    boolean isPrepared -> h
    boolean isPrepared() -> b
    void prepare() -> c
    com.badlogic.gdx.graphics.Pixmap ensurePot(com.badlogic.gdx.graphics.Pixmap) -> a
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    int getWidth() -> f
    int getHeight() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    boolean useMipMaps() -> i
    boolean isManaged() -> j
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    void consumeCustomData(int) -> a
com.badlogic.gdx.graphics.glutils.FrameBuffer -> com.badlogic.gdx.graphics.glutils.d:
    java.util.Map buffers -> f
    com.badlogic.gdx.graphics.Texture colorTexture -> a
    int defaultFramebufferHandle -> g
    boolean defaultFramebufferHandleInitialized -> h
    int framebufferHandle -> i
    int depthbufferHandle -> j
    int width -> b
    int height -> c
    boolean hasDepth -> d
    com.badlogic.gdx.graphics.Pixmap$Format format -> e
    void setupTexture() -> a
    void build() -> k
    void dispose() -> c
    void bind() -> b
    void unbind() -> d
    void begin() -> e
    void setFrameBufferViewport() -> f
    void end() -> g
    void setDefaultFrameBufferViewport() -> h
    com.badlogic.gdx.graphics.Texture getColorBufferTexture() -> i
    void addManagedFrameBuffer(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.FrameBuffer) -> a
    void invalidateAllFrameBuffers(com.badlogic.gdx.Application) -> a
    void clearAllFrameBuffers(com.badlogic.gdx.Application) -> b
    java.lang.StringBuilder getManagedStatus(java.lang.StringBuilder) -> a
    java.lang.String getManagedStatus() -> j
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer -> com.badlogic.gdx.graphics.glutils.e:
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    void color(com.badlogic.gdx.graphics.Color) -> a
    void color(float,float,float,float) -> a
    void vertex(float,float,float) -> a
    void end() -> a
    int getNumVertices() -> b
    int getMaxVertices() -> c
    void dispose() -> d
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20 -> com.badlogic.gdx.graphics.glutils.f:
    int primitiveType -> a
    int vertexIdx -> b
    int numSetTexCoords -> c
    int maxVertices -> d
    int numVertices -> e
    com.badlogic.gdx.graphics.Mesh mesh -> f
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> g
    boolean ownsShader -> h
    int numTexCoords -> i
    int vertexSize -> j
    int normalOffset -> k
    int colorOffset -> l
    int texCoordOffset -> m
    com.badlogic.gdx.math.Matrix4 projModelView -> n
    float[] vertices -> o
    java.lang.String[] shaderUniformNames -> p
    com.badlogic.gdx.graphics.VertexAttribute[] buildVertexAttributes(boolean,boolean,int) -> b
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    void color(com.badlogic.gdx.graphics.Color) -> a
    void color(float,float,float,float) -> a
    void vertex(float,float,float) -> a
    void flush() -> e
    void end() -> a
    int getNumVertices() -> b
    int getMaxVertices() -> c
    void dispose() -> d
    java.lang.String createVertexShader(boolean,boolean,int) -> c
    java.lang.String createFragmentShader(boolean,boolean,int) -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader(boolean,boolean,int) -> a
com.badlogic.gdx.graphics.glutils.IndexArray -> com.badlogic.gdx.graphics.glutils.g:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void bind() -> e
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.IndexBufferObject -> com.badlogic.gdx.graphics.glutils.h:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> d
    boolean isDirect -> e
    boolean isDirty -> f
    boolean isBound -> g
    int usage -> h
    int createBufferObject() -> h
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void bind() -> e
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData -> com.badlogic.gdx.graphics.glutils.i:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> d
    boolean isDirect -> e
    boolean isDirty -> f
    boolean isBound -> g
    int usage -> h
    int createBufferObject() -> h
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void bind() -> e
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.IndexData -> com.badlogic.gdx.graphics.glutils.j:
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void bind() -> e
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.MipMapGenerator -> com.badlogic.gdx.graphics.glutils.k:
    boolean useHWMipMap -> a
    void generateMipMap(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void generateMipMapGLES20(int,com.badlogic.gdx.graphics.Pixmap) -> a
    void generateMipMapDesktop(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> b
    void generateMipMapCPU(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> c
com.badlogic.gdx.graphics.glutils.PixmapTextureData -> com.badlogic.gdx.graphics.glutils.l:
    com.badlogic.gdx.graphics.Pixmap pixmap -> a
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    boolean useMipMaps -> c
    boolean disposePixmap -> d
    boolean managed -> e
    boolean disposePixmap() -> e
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    int getWidth() -> f
    int getHeight() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    boolean useMipMaps() -> i
    boolean isManaged() -> j
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    void consumeCustomData(int) -> a
    boolean isPrepared() -> b
    void prepare() -> c
com.badlogic.gdx.graphics.glutils.ShaderProgram -> com.badlogic.gdx.graphics.glutils.m:
    boolean pedantic -> a
    com.badlogic.gdx.utils.ObjectMap shaders -> e
    java.lang.String log -> f
    boolean isCompiled -> g
    com.badlogic.gdx.utils.ObjectIntMap uniforms -> h
    com.badlogic.gdx.utils.ObjectIntMap uniformTypes -> i
    com.badlogic.gdx.utils.ObjectIntMap uniformSizes -> j
    java.lang.String[] uniformNames -> k
    com.badlogic.gdx.utils.ObjectIntMap attributes -> l
    com.badlogic.gdx.utils.ObjectIntMap attributeTypes -> m
    com.badlogic.gdx.utils.ObjectIntMap attributeSizes -> n
    java.lang.String[] attributeNames -> o
    int program -> p
    int vertexShaderHandle -> q
    int fragmentShaderHandle -> r
    java.nio.FloatBuffer matrix -> s
    java.lang.String vertexShaderSource -> t
    java.lang.String fragmentShaderSource -> u
    boolean invalidated -> v
    java.nio.ByteBuffer buffer -> w
    java.nio.FloatBuffer floatBuffer -> x
    java.nio.IntBuffer intBuffer -> y
    int refCount -> z
    java.nio.IntBuffer intbuf -> b
    java.nio.IntBuffer params -> c
    java.nio.IntBuffer type -> d
    void compileShaders(java.lang.String,java.lang.String) -> a
    int loadShader(int,java.lang.String) -> a
    int linkProgram() -> g
    java.lang.String getLog() -> a
    boolean isCompiled() -> b
    int fetchAttributeLocation(java.lang.String) -> c
    int fetchUniformLocation(java.lang.String) -> d
    int fetchUniformLocation(java.lang.String,boolean) -> a
    void setUniformi(java.lang.String,int) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4,boolean) -> a
    void setVertexAttribute(int,int,int,boolean,int,java.nio.Buffer) -> a
    void setVertexAttribute(int,int,int,boolean,int,int) -> a
    void begin() -> d
    void end() -> e
    void dispose() -> c
    void disableVertexAttribute(java.lang.String) -> a
    void disableVertexAttribute(int) -> a
    void enableVertexAttribute(int) -> b
    void checkManaged() -> h
    void addManagedShader(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void invalidateAllShaderPrograms(com.badlogic.gdx.Application) -> a
    void clearAllShaderPrograms(com.badlogic.gdx.Application) -> b
    java.lang.String getManagedStatus() -> f
    void fetchUniforms() -> i
    void fetchAttributes() -> j
    int getAttributeLocation(java.lang.String) -> b
com.badlogic.gdx.graphics.glutils.ShapeRenderer -> com.badlogic.gdx.graphics.glutils.n:
    com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer renderer -> a
    boolean matrixDirty -> b
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> c
    com.badlogic.gdx.math.Matrix4 transformMatrix -> d
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> e
    com.badlogic.gdx.math.Vector2 tmp -> f
    com.badlogic.gdx.graphics.Color color -> g
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType shapeType -> h
    boolean autoShapeType -> i
    float defaultRectLineWidth -> j
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> a
    void setAutoShapeType(boolean) -> a
    void begin() -> b
    void begin(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> a
    void set(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> b
    void rect(float,float,float,float) -> a
    void rect(float,float,float,float,float,float,float,float,float) -> a
    void rect(float,float,float,float,float,float,float,float,float,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color) -> a
    void check(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,int) -> a
    void end() -> d
    void flush() -> e
    boolean isDrawing() -> f
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType -> com.badlogic.gdx.graphics.glutils.o:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Point -> a
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Line -> b
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Filled -> c
    int glType -> d
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] $VALUES -> e
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] values() -> values
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType valueOf(java.lang.String) -> valueOf
    int getGlType() -> a
com.badlogic.gdx.graphics.glutils.VertexArray -> com.badlogic.gdx.graphics.glutils.p:
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    java.nio.FloatBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    boolean isBound -> d
    void dispose() -> c
    java.nio.FloatBuffer getBuffer() -> a
    int getNumVertices() -> b
    void setVertices(float[],int,int) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> d
com.badlogic.gdx.graphics.glutils.VertexBufferObject -> com.badlogic.gdx.graphics.glutils.q:
    java.nio.IntBuffer tmpHandle -> a
    com.badlogic.gdx.graphics.VertexAttributes attributes -> b
    java.nio.FloatBuffer buffer -> c
    java.nio.ByteBuffer byteBuffer -> d
    int bufferHandle -> e
    boolean isStatic -> f
    int usage -> g
    boolean isDirty -> h
    boolean isBound -> i
    int createBufferObject() -> f
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> d
    int getNumVertices() -> b
    java.nio.FloatBuffer getBuffer() -> a
    void bufferChanged() -> g
    void setVertices(float[],int,int) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void invalidate() -> e
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData -> com.badlogic.gdx.graphics.glutils.r:
    java.nio.IntBuffer tmpHandle -> a
    com.badlogic.gdx.graphics.VertexAttributes attributes -> b
    java.nio.FloatBuffer buffer -> c
    java.nio.ByteBuffer byteBuffer -> d
    int bufferHandle -> e
    boolean isDirect -> f
    boolean isStatic -> g
    int usage -> h
    boolean isDirty -> i
    boolean isBound -> j
    int createBufferObject() -> e
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> d
    int getNumVertices() -> b
    java.nio.FloatBuffer getBuffer() -> a
    void bufferChanged() -> f
    void setVertices(float[],int,int) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.VertexData -> com.badlogic.gdx.graphics.glutils.s:
    int getNumVertices() -> b
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> d
    void setVertices(float[],int,int) -> a
    java.nio.FloatBuffer getBuffer() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void dispose() -> c
com.badlogic.gdx.input.GestureDetector -> com.badlogic.gdx.d.a:
    com.badlogic.gdx.input.GestureDetector$GestureListener listener -> a
    float tapSquareSize -> d
    long tapCountInterval -> e
    float longPressSeconds -> f
    long maxFlingDelay -> g
    boolean inTapSquare -> h
    int tapCount -> i
    long lastTapTime -> j
    float lastTapX -> k
    float lastTapY -> l
    int lastTapButton -> m
    int lastTapPointer -> n
    boolean longPressFired -> b
    boolean pinching -> o
    boolean panning -> p
    com.badlogic.gdx.input.GestureDetector$VelocityTracker tracker -> q
    float tapSquareCenterX -> r
    float tapSquareCenterY -> s
    long gestureStartTime -> t
    com.badlogic.gdx.math.Vector2 pointer1 -> c
    com.badlogic.gdx.math.Vector2 pointer2 -> u
    com.badlogic.gdx.math.Vector2 initialPointer1 -> v
    com.badlogic.gdx.math.Vector2 initialPointer2 -> w
    com.badlogic.gdx.utils.Timer$Task longPressTask -> x
    boolean touchDown(int,int,int,int) -> a
    boolean touchDown(float,float,int,int) -> a
    boolean touchDragged(int,int,int) -> a
    boolean touchDragged(float,float,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchUp(float,float,int,int) -> b
    void cancel() -> a
    boolean isPanning() -> b
    boolean isWithinTapSquare(float,float,float,float) -> a
com.badlogic.gdx.input.GestureDetector$1 -> com.badlogic.gdx.d.b:
    com.badlogic.gdx.input.GestureDetector this$0 -> a
    void run() -> run
com.badlogic.gdx.input.GestureDetector$GestureAdapter -> com.badlogic.gdx.d.c:
    boolean touchDown(float,float,int,int) -> a
    boolean tap(float,float,int,int) -> b
    boolean longPress(float,float) -> a
    boolean fling(float,float,int) -> a
    boolean pan(float,float,float,float) -> a
    boolean panStop(float,float,int,int) -> c
    boolean zoom(float,float) -> b
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.input.GestureDetector$GestureListener -> com.badlogic.gdx.d.d:
    boolean touchDown(float,float,int,int) -> a
    boolean tap(float,float,int,int) -> b
    boolean longPress(float,float) -> a
    boolean fling(float,float,int) -> a
    boolean pan(float,float,float,float) -> a
    boolean panStop(float,float,int,int) -> c
    boolean zoom(float,float) -> b
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.input.GestureDetector$VelocityTracker -> com.badlogic.gdx.d.e:
    int sampleSize -> a
    float lastX -> b
    float lastY -> c
    float deltaX -> d
    float deltaY -> e
    long lastTime -> f
    int numSamples -> g
    float[] meanX -> h
    float[] meanY -> i
    long[] meanTime -> j
    void start(float,float,long) -> a
    void update(float,float,long) -> b
    float getVelocityX() -> a
    float getVelocityY() -> b
    float getAverage(float[],int) -> a
    long getAverage(long[],int) -> a
com.badlogic.gdx.math.EarClippingTriangulator -> com.badlogic.gdx.math.a:
    com.badlogic.gdx.utils.ShortArray indicesArray -> a
    short[] indices -> b
    float[] vertices -> c
    int vertexCount -> d
    com.badlogic.gdx.utils.IntArray vertexTypes -> e
    com.badlogic.gdx.utils.ShortArray triangles -> f
    com.badlogic.gdx.utils.ShortArray computeTriangles(float[]) -> a
    com.badlogic.gdx.utils.ShortArray computeTriangles(float[],int,int) -> a
    void triangulate() -> a
    int classifyVertex(int) -> a
    int findEarTip() -> b
    boolean isEarTip(int) -> b
    void cutEarTip(int) -> c
    int previousIndex(int) -> d
    int nextIndex(int) -> e
    boolean areVerticesClockwise(float[],int,int) -> b
    int computeSpannedAreaSign(float,float,float,float,float,float) -> a
com.badlogic.gdx.math.Frustum -> com.badlogic.gdx.math.b:
    com.badlogic.gdx.math.Vector3[] clipSpacePlanePoints -> a
    float[] clipSpacePlanePointsArray -> b
    com.badlogic.gdx.math.Plane[] planes -> c
    com.badlogic.gdx.math.Vector3[] planePoints -> d
    float[] planePointsArray -> e
    void update(com.badlogic.gdx.math.Matrix4) -> a
com.badlogic.gdx.math.Interpolation -> com.badlogic.gdx.math.c:
    com.badlogic.gdx.math.Interpolation linear -> a
    com.badlogic.gdx.math.Interpolation fade -> b
    com.badlogic.gdx.math.Interpolation$Pow pow2 -> c
    com.badlogic.gdx.math.Interpolation$PowIn pow2In -> d
    com.badlogic.gdx.math.Interpolation$PowOut pow2Out -> e
    com.badlogic.gdx.math.Interpolation$Pow pow3 -> f
    com.badlogic.gdx.math.Interpolation$PowIn pow3In -> g
    com.badlogic.gdx.math.Interpolation$PowOut pow3Out -> h
    com.badlogic.gdx.math.Interpolation$Pow pow4 -> i
    com.badlogic.gdx.math.Interpolation$PowIn pow4In -> j
    com.badlogic.gdx.math.Interpolation$PowOut pow4Out -> k
    com.badlogic.gdx.math.Interpolation$Pow pow5 -> l
    com.badlogic.gdx.math.Interpolation$PowIn pow5In -> m
    com.badlogic.gdx.math.Interpolation$PowOut pow5Out -> n
    com.badlogic.gdx.math.Interpolation sine -> o
    com.badlogic.gdx.math.Interpolation sineIn -> p
    com.badlogic.gdx.math.Interpolation sineOut -> q
    com.badlogic.gdx.math.Interpolation exp10 -> r
    com.badlogic.gdx.math.Interpolation exp10In -> s
    com.badlogic.gdx.math.Interpolation exp10Out -> t
    com.badlogic.gdx.math.Interpolation exp5 -> u
    com.badlogic.gdx.math.Interpolation exp5In -> v
    com.badlogic.gdx.math.Interpolation exp5Out -> w
    com.badlogic.gdx.math.Interpolation circle -> x
    com.badlogic.gdx.math.Interpolation circleIn -> y
    com.badlogic.gdx.math.Interpolation circleOut -> z
    com.badlogic.gdx.math.Interpolation$Elastic elastic -> A
    com.badlogic.gdx.math.Interpolation$Elastic elasticIn -> B
    com.badlogic.gdx.math.Interpolation$Elastic elasticOut -> C
    com.badlogic.gdx.math.Interpolation swing -> D
    com.badlogic.gdx.math.Interpolation swingIn -> E
    com.badlogic.gdx.math.Interpolation swingOut -> F
    com.badlogic.gdx.math.Interpolation bounce -> G
    com.badlogic.gdx.math.Interpolation bounceIn -> H
    com.badlogic.gdx.math.Interpolation bounceOut -> I
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$1 -> com.badlogic.gdx.math.d:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$2 -> com.badlogic.gdx.math.e:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$3 -> com.badlogic.gdx.math.f:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$4 -> com.badlogic.gdx.math.g:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$5 -> com.badlogic.gdx.math.h:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$6 -> com.badlogic.gdx.math.i:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$7 -> com.badlogic.gdx.math.j:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$8 -> com.badlogic.gdx.math.k:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Bounce -> com.badlogic.gdx.math.l:
    float out(float) -> b
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$BounceIn -> com.badlogic.gdx.math.m:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$BounceOut -> com.badlogic.gdx.math.n:
    float[] widths -> J
    float[] heights -> K
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Elastic -> com.badlogic.gdx.math.o:
    float value -> J
    float power -> K
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticIn -> com.badlogic.gdx.math.p:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticOut -> com.badlogic.gdx.math.q:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Exp -> com.badlogic.gdx.math.r:
    float value -> J
    float power -> K
    float min -> L
    float scale -> M
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpIn -> com.badlogic.gdx.math.s:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpOut -> com.badlogic.gdx.math.t:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Pow -> com.badlogic.gdx.math.u:
    int power -> J
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowIn -> com.badlogic.gdx.math.v:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowOut -> com.badlogic.gdx.math.w:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Swing -> com.badlogic.gdx.math.x:
    float scale -> J
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingIn -> com.badlogic.gdx.math.y:
    float scale -> J
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingOut -> com.badlogic.gdx.math.z:
    float scale -> J
    float apply(float) -> a
com.badlogic.gdx.math.MathUtils -> com.badlogic.gdx.math.aa:
    int ATAN2_DIM -> a
    float INV_ATAN2_DIM_MINUS_1 -> c
    java.util.Random random -> b
    float sin(float) -> a
    float cos(float) -> b
    float sinDeg(float) -> c
    float cosDeg(float) -> d
    int random(int) -> a
    int random(int,int) -> a
    float random() -> a
    float random(float) -> e
    int nextPowerOfTwo(int) -> b
    boolean isPowerOfTwo(int) -> c
    float clamp(float,float,float) -> a
com.badlogic.gdx.math.MathUtils$Sin -> com.badlogic.gdx.math.ab:
    float[] table -> a
com.badlogic.gdx.math.Matrix3 -> com.badlogic.gdx.math.ac:
    float[] val -> a
    float[] tmp -> b
    com.badlogic.gdx.math.Matrix3 idt() -> a
    com.badlogic.gdx.math.Matrix3 mul(com.badlogic.gdx.math.Matrix3) -> a
    com.badlogic.gdx.math.Matrix3 setToTranslation(float,float) -> a
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.Matrix3 set(com.badlogic.gdx.math.Matrix3) -> b
    com.badlogic.gdx.math.Matrix3 trn(float,float) -> b
    com.badlogic.gdx.math.Matrix3 translate(float,float) -> c
    com.badlogic.gdx.math.Matrix3 rotate(float) -> a
    com.badlogic.gdx.math.Matrix3 rotateRad(float) -> b
    com.badlogic.gdx.math.Matrix3 scale(float,float) -> d
    void mul(float[],float[]) -> a
com.badlogic.gdx.math.Matrix4 -> com.badlogic.gdx.math.Matrix4:
    float[] tmp -> a
    float[] val -> b
    com.badlogic.gdx.math.Quaternion quat -> c
    com.badlogic.gdx.math.Quaternion quat2 -> d
    com.badlogic.gdx.math.Vector3 l_vez -> e
    com.badlogic.gdx.math.Vector3 l_vex -> f
    com.badlogic.gdx.math.Vector3 l_vey -> g
    com.badlogic.gdx.math.Vector3 tmpVec -> h
    com.badlogic.gdx.math.Matrix4 tmpMat -> i
    com.badlogic.gdx.math.Vector3 right -> j
    com.badlogic.gdx.math.Vector3 tmpForward -> k
    com.badlogic.gdx.math.Vector3 tmpUp -> l
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Matrix4 set(float[]) -> a
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Quaternion,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 set(float,float,float,float,float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 mul(com.badlogic.gdx.math.Matrix4) -> b
    com.badlogic.gdx.math.Matrix4 idt() -> a
    com.badlogic.gdx.math.Matrix4 inv() -> b
    com.badlogic.gdx.math.Matrix4 setToOrtho2D(float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 setToOrtho(float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 setToTranslation(float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix3) -> a
    void mul(float[],float[]) -> mul
    void prj(float[],float[],int,int,int) -> prj
    boolean inv(float[]) -> inv
    com.badlogic.gdx.math.Matrix4 translate(float,float,float) -> b
    com.badlogic.gdx.math.Matrix4 rotate(com.badlogic.gdx.math.Quaternion) -> a
    com.badlogic.gdx.math.Matrix4 scale(float,float,float) -> c
com.badlogic.gdx.math.Plane -> com.badlogic.gdx.math.ad:
    com.badlogic.gdx.math.Vector3 normal -> a
    float d -> b
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.math.Quaternion -> com.badlogic.gdx.math.ae:
    com.badlogic.gdx.math.Quaternion tmp1 -> e
    com.badlogic.gdx.math.Quaternion tmp2 -> f
    float x -> a
    float y -> b
    float z -> c
    float w -> d
    com.badlogic.gdx.math.Quaternion set(float,float,float,float) -> a
    com.badlogic.gdx.math.Quaternion set(com.badlogic.gdx.math.Quaternion) -> a
    java.lang.String toString() -> toString
    void toMatrix(float[]) -> a
    com.badlogic.gdx.math.Quaternion idt() -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.math.RandomXS128 -> com.badlogic.gdx.math.af:
    long seed0 -> a
    long seed1 -> b
    long nextLong() -> nextLong
    int next(int) -> next
    int nextInt() -> nextInt
    int nextInt(int) -> nextInt
    long nextLong(long) -> a
    double nextDouble() -> nextDouble
    float nextFloat() -> nextFloat
    boolean nextBoolean() -> nextBoolean
    void nextBytes(byte[]) -> nextBytes
    void setSeed(long) -> setSeed
    void setState(long,long) -> a
    long murmurHash3(long) -> b
com.badlogic.gdx.math.Rectangle -> com.badlogic.gdx.math.ag:
    com.badlogic.gdx.math.Rectangle tmp -> a
    com.badlogic.gdx.math.Rectangle tmp2 -> b
    float x -> c
    float y -> d
    float width -> e
    float height -> f
    com.badlogic.gdx.math.Rectangle set(float,float,float,float) -> a
    boolean contains(float,float) -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.math.Vector2 -> com.badlogic.gdx.math.ah:
    com.badlogic.gdx.math.Vector2 X -> a
    com.badlogic.gdx.math.Vector2 Y -> b
    com.badlogic.gdx.math.Vector2 Zero -> c
    float x -> d
    float y -> e
    com.badlogic.gdx.math.Vector2 set(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 set(float,float) -> a
    float dst(com.badlogic.gdx.math.Vector2) -> b
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.math.Vector3 -> com.badlogic.gdx.math.ai:
    float x -> a
    float y -> b
    float z -> c
    com.badlogic.gdx.math.Vector3 X -> d
    com.badlogic.gdx.math.Vector3 Y -> e
    com.badlogic.gdx.math.Vector3 Z -> f
    com.badlogic.gdx.math.Vector3 Zero -> g
    com.badlogic.gdx.math.Matrix4 tmpMat -> h
    com.badlogic.gdx.math.Vector3 set(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 set(com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Vector3 add(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Vector3 add(float,float,float) -> b
    com.badlogic.gdx.math.Vector3 sub(com.badlogic.gdx.math.Vector3) -> c
    com.badlogic.gdx.math.Vector3 sub(float,float,float) -> c
    com.badlogic.gdx.math.Vector3 scl(float) -> a
    float len2() -> a
    com.badlogic.gdx.math.Vector3 nor() -> b
    float dot(com.badlogic.gdx.math.Vector3) -> d
    com.badlogic.gdx.math.Vector3 crs(com.badlogic.gdx.math.Vector3) -> e
    com.badlogic.gdx.math.Vector3 crs(float,float,float) -> d
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Vector3 prj(com.badlogic.gdx.math.Matrix4) -> b
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.math.WindowedMean -> com.badlogic.gdx.math.aj:
    float[] values -> a
    int added_values -> b
    int last_value -> c
    float mean -> d
    boolean dirty -> e
    boolean hasEnoughData() -> a
    void clear() -> b
    void addValue(float) -> a
    float getMean() -> c
com.badlogic.gdx.math.collision.Ray -> com.badlogic.gdx.math.a.a:
    com.badlogic.gdx.math.Vector3 origin -> a
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 tmp -> c
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.badlogic.gdx.net.NetJavaImpl -> com.badlogic.gdx.e.a:
    java.util.concurrent.ExecutorService executorService -> d
    com.badlogic.gdx.utils.ObjectMap connections -> a
    com.badlogic.gdx.utils.ObjectMap listeners -> b
    java.util.concurrent.locks.Lock lock -> c
com.badlogic.gdx.physics.box2d.Body -> com.badlogic.gdx.physics.box2d.Body:
    long addr -> a
    float[] tmp -> g
    com.badlogic.gdx.physics.box2d.World world -> h
    com.badlogic.gdx.utils.Array fixtures -> i
    com.badlogic.gdx.utils.Array joints -> b
    java.lang.Object userData -> j
    com.badlogic.gdx.physics.box2d.Transform transform -> k
    com.badlogic.gdx.math.Vector2 position -> l
    com.badlogic.gdx.math.Vector2 worldCenter -> m
    com.badlogic.gdx.math.Vector2 localCenter -> n
    com.badlogic.gdx.math.Vector2 linearVelocity -> o
    com.badlogic.gdx.physics.box2d.MassData massData -> p
    com.badlogic.gdx.math.Vector2 localPoint -> q
    com.badlogic.gdx.math.Vector2 worldVector -> r
    com.badlogic.gdx.math.Vector2 localPoint2 -> c
    com.badlogic.gdx.math.Vector2 localVector -> d
    com.badlogic.gdx.math.Vector2 linVelWorld -> e
    com.badlogic.gdx.math.Vector2 linVelLoc -> f
    void reset(long) -> a
    com.badlogic.gdx.physics.box2d.Fixture createFixture(com.badlogic.gdx.physics.box2d.FixtureDef) -> a
    long jniCreateFixture(long,long,float,float,float,boolean,short,short,short) -> jniCreateFixture
    com.badlogic.gdx.math.Vector2 getPosition() -> a
    void jniGetPosition(long,float[]) -> jniGetPosition
    void setLinearVelocity(com.badlogic.gdx.math.Vector2) -> a
    void setLinearVelocity(float,float) -> a
    void jniSetLinearVelocity(long,float,float) -> jniSetLinearVelocity
    com.badlogic.gdx.math.Vector2 getLinearVelocity() -> b
    void jniGetLinearVelocity(long,float[]) -> jniGetLinearVelocity
    void applyForce(float,float,float,float,boolean) -> a
    void jniApplyForce(long,float,float,float,float,boolean) -> jniApplyForce
    void applyLinearImpulse(float,float,float,float,boolean) -> b
    void jniApplyLinearImpulse(long,float,float,float,float,boolean) -> jniApplyLinearImpulse
    void setBullet(boolean) -> a
    void jniSetBullet(long,boolean) -> jniSetBullet
    void setFixedRotation(boolean) -> b
    void jniSetFixedRotation(long,boolean) -> jniSetFixedRotation
    com.badlogic.gdx.utils.Array getFixtureList() -> c
    void setGravityScale(float) -> a
    void jniSetGravityScale(long,float) -> jniSetGravityScale
    java.lang.Object getUserData() -> d
    void setUserData(java.lang.Object) -> a
com.badlogic.gdx.physics.box2d.BodyDef -> com.badlogic.gdx.physics.box2d.a:
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType type -> a
    com.badlogic.gdx.math.Vector2 position -> b
    float angle -> c
    com.badlogic.gdx.math.Vector2 linearVelocity -> d
    float angularVelocity -> e
    float linearDamping -> f
    float angularDamping -> g
    boolean allowSleep -> h
    boolean awake -> i
    boolean fixedRotation -> j
    boolean bullet -> k
    boolean active -> l
    float gravityScale -> m
com.badlogic.gdx.physics.box2d.BodyDef$BodyType -> com.badlogic.gdx.physics.box2d.b:
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType StaticBody -> a
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType KinematicBody -> b
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType DynamicBody -> c
    int value -> d
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType[] $VALUES -> e
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType[] values() -> values
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType valueOf(java.lang.String) -> valueOf
    int getValue() -> a
com.badlogic.gdx.physics.box2d.Box2DDebugRenderer -> com.badlogic.gdx.physics.box2d.c:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer renderer -> a
    com.badlogic.gdx.math.Vector2[] vertices -> j
    com.badlogic.gdx.math.Vector2 lower -> k
    com.badlogic.gdx.math.Vector2 upper -> l
    com.badlogic.gdx.utils.Array bodies -> m
    com.badlogic.gdx.utils.Array joints -> n
    boolean drawBodies -> o
    boolean drawJoints -> p
    boolean drawAABBs -> q
    boolean drawInactiveBodies -> r
    boolean drawVelocities -> s
    boolean drawContacts -> t
    com.badlogic.gdx.graphics.Color SHAPE_NOT_ACTIVE -> b
    com.badlogic.gdx.graphics.Color SHAPE_STATIC -> c
    com.badlogic.gdx.graphics.Color SHAPE_KINEMATIC -> d
    com.badlogic.gdx.graphics.Color SHAPE_NOT_AWAKE -> e
    com.badlogic.gdx.graphics.Color SHAPE_AWAKE -> f
    com.badlogic.gdx.graphics.Color JOINT_COLOR -> g
    com.badlogic.gdx.graphics.Color AABB_COLOR -> h
    com.badlogic.gdx.graphics.Color VELOCITY_COLOR -> i
    com.badlogic.gdx.math.Vector2 t -> u
    com.badlogic.gdx.math.Vector2 axis -> v
    com.badlogic.gdx.math.Vector2 f -> w
    com.badlogic.gdx.math.Vector2 v -> x
    com.badlogic.gdx.math.Vector2 lv -> y
    void dispose() -> a
com.badlogic.gdx.physics.box2d.ChainShape -> com.badlogic.gdx.physics.box2d.ChainShape:
    boolean isLooped -> a
    float[] verts -> c
    long newChainShape() -> newChainShape
com.badlogic.gdx.physics.box2d.CircleShape -> com.badlogic.gdx.physics.box2d.CircleShape:
    float[] tmp -> a
    com.badlogic.gdx.math.Vector2 position -> c
    long newCircleShape() -> newCircleShape
com.badlogic.gdx.physics.box2d.Contact -> com.badlogic.gdx.physics.box2d.Contact:
    long addr -> a
    com.badlogic.gdx.physics.box2d.World world -> b
    com.badlogic.gdx.physics.box2d.WorldManifold worldManifold -> c
    float[] tmp -> d
    com.badlogic.gdx.physics.box2d.WorldManifold getWorldManifold() -> a
    int jniGetWorldManifold(long,float[]) -> jniGetWorldManifold
    void setEnabled(boolean) -> a
    void jniSetEnabled(long,boolean) -> jniSetEnabled
    com.badlogic.gdx.physics.box2d.Fixture getFixtureA() -> b
    long jniGetFixtureA(long) -> jniGetFixtureA
    com.badlogic.gdx.physics.box2d.Fixture getFixtureB() -> c
    long jniGetFixtureB(long) -> jniGetFixtureB
com.badlogic.gdx.physics.box2d.ContactFilter -> com.badlogic.gdx.physics.box2d.d:
    boolean shouldCollide(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.physics.box2d.Fixture) -> a
com.badlogic.gdx.physics.box2d.ContactImpulse -> com.badlogic.gdx.physics.box2d.e:
    com.badlogic.gdx.physics.box2d.World world -> a
    long addr -> b
    float[] tmp -> c
    float[] normalImpulses -> d
    float[] tangentImpulses -> e
com.badlogic.gdx.physics.box2d.ContactListener -> com.badlogic.gdx.physics.box2d.f:
    void beginContact(com.badlogic.gdx.physics.box2d.Contact) -> a
    void endContact(com.badlogic.gdx.physics.box2d.Contact) -> b
    void preSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.Manifold) -> a
    void postSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.ContactImpulse) -> a
com.badlogic.gdx.physics.box2d.EdgeShape -> com.badlogic.gdx.physics.box2d.EdgeShape:
    float[] vertex -> a
    long newEdgeShape() -> newEdgeShape
com.badlogic.gdx.physics.box2d.Filter -> com.badlogic.gdx.physics.box2d.g:
    short categoryBits -> a
    short maskBits -> b
    short groupIndex -> c
com.badlogic.gdx.physics.box2d.Fixture -> com.badlogic.gdx.physics.box2d.Fixture:
    com.badlogic.gdx.physics.box2d.Body body -> d
    long addr -> a
    com.badlogic.gdx.physics.box2d.Shape shape -> b
    java.lang.Object userData -> c
    short[] tmp -> e
    com.badlogic.gdx.physics.box2d.Filter filter -> f
    void reset(com.badlogic.gdx.physics.box2d.Body,long) -> a
    com.badlogic.gdx.physics.box2d.Shape getShape() -> a
    long jniGetShape(long) -> jniGetShape
    void setSensor(boolean) -> a
    void jniSetSensor(long,boolean) -> jniSetSensor
    boolean isSensor() -> b
    boolean jniIsSensor(long) -> jniIsSensor
    com.badlogic.gdx.physics.box2d.Filter getFilterData() -> c
    void jniGetFilterData(long,short[]) -> jniGetFilterData
    com.badlogic.gdx.physics.box2d.Body getBody() -> d
com.badlogic.gdx.physics.box2d.FixtureDef -> com.badlogic.gdx.physics.box2d.h:
    com.badlogic.gdx.physics.box2d.Shape shape -> a
    float friction -> b
    float restitution -> c
    float density -> d
    boolean isSensor -> e
    com.badlogic.gdx.physics.box2d.Filter filter -> f
com.badlogic.gdx.physics.box2d.Manifold -> com.badlogic.gdx.physics.box2d.i:
    long addr -> a
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint[] points -> b
    com.badlogic.gdx.math.Vector2 localNormal -> c
    com.badlogic.gdx.math.Vector2 localPoint -> d
    int[] tmpInt -> e
    float[] tmpFloat -> f
com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint -> com.badlogic.gdx.physics.box2d.j:
    com.badlogic.gdx.math.Vector2 localPoint -> a
    float normalImpulse -> b
    float tangentImpulse -> c
    int contactID -> d
    com.badlogic.gdx.physics.box2d.Manifold this$0 -> e
    java.lang.String toString() -> toString
com.badlogic.gdx.physics.box2d.MassData -> com.badlogic.gdx.physics.box2d.k:
    com.badlogic.gdx.math.Vector2 center -> a
com.badlogic.gdx.physics.box2d.PolygonShape -> com.badlogic.gdx.physics.box2d.PolygonShape:
    float[] verts -> a
    long newPolygonShape() -> newPolygonShape
    void setAsBox(float,float) -> a
    void jniSetAsBox(long,float,float) -> jniSetAsBox
    void setAsBox(float,float,com.badlogic.gdx.math.Vector2,float) -> a
    void jniSetAsBox(long,float,float,float,float,float) -> jniSetAsBox
com.badlogic.gdx.physics.box2d.QueryCallback -> com.badlogic.gdx.physics.box2d.l:
    boolean reportFixture(com.badlogic.gdx.physics.box2d.Fixture) -> a
com.badlogic.gdx.physics.box2d.RayCastCallback -> com.badlogic.gdx.physics.box2d.m:
    float reportRayFixture(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float) -> a
com.badlogic.gdx.physics.box2d.Shape -> com.badlogic.gdx.physics.box2d.Shape:
    long addr -> b
    void dispose() -> a
    void jniDispose(long) -> jniDispose
    int jniGetType(long) -> jniGetType
com.badlogic.gdx.physics.box2d.Transform -> com.badlogic.gdx.physics.box2d.n:
    float[] vals -> a
    com.badlogic.gdx.math.Vector2 position -> b
com.badlogic.gdx.physics.box2d.World -> com.badlogic.gdx.physics.box2d.World:
    com.badlogic.gdx.utils.Pool freeBodies -> a
    com.badlogic.gdx.utils.Pool freeFixtures -> b
    long addr -> j
    com.badlogic.gdx.utils.LongMap bodies -> c
    com.badlogic.gdx.utils.LongMap fixtures -> d
    com.badlogic.gdx.utils.LongMap joints -> e
    com.badlogic.gdx.physics.box2d.ContactFilter contactFilter -> f
    com.badlogic.gdx.physics.box2d.ContactListener contactListener -> g
    float[] tmpGravity -> h
    com.badlogic.gdx.math.Vector2 gravity -> i
    com.badlogic.gdx.physics.box2d.QueryCallback queryCallback -> k
    long[] contactAddrs -> l
    com.badlogic.gdx.utils.Array contacts -> m
    com.badlogic.gdx.utils.Array freeContacts -> n
    com.badlogic.gdx.physics.box2d.Contact contact -> o
    com.badlogic.gdx.physics.box2d.Manifold manifold -> p
    com.badlogic.gdx.physics.box2d.ContactImpulse impulse -> q
    com.badlogic.gdx.physics.box2d.RayCastCallback rayCastCallback -> r
    com.badlogic.gdx.math.Vector2 rayPoint -> s
    com.badlogic.gdx.math.Vector2 rayNormal -> t
    long newWorld(float,float,boolean) -> newWorld
    void setContactListener(com.badlogic.gdx.physics.box2d.ContactListener) -> a
    com.badlogic.gdx.physics.box2d.Body createBody(com.badlogic.gdx.physics.box2d.BodyDef) -> a
    long jniCreateBody(long,int,float,float,float,float,float,float,float,float,boolean,boolean,boolean,boolean,boolean,float) -> jniCreateBody
    void step(float,int,int) -> a
    void jniStep(long,float,int,int) -> jniStep
    void dispose() -> c
    void jniDispose(long) -> jniDispose
    boolean contactFilter(long,long) -> contactFilter
    void beginContact(long) -> beginContact
    void endContact(long) -> endContact
    void preSolve(long,long) -> preSolve
    void postSolve(long,long) -> postSolve
    boolean reportFixture(long) -> reportFixture
    float reportRayFixture(long,float,float,float,float,float) -> reportRayFixture
com.badlogic.gdx.physics.box2d.World$1 -> com.badlogic.gdx.physics.box2d.o:
    com.badlogic.gdx.physics.box2d.World this$0 -> a
    com.badlogic.gdx.physics.box2d.Body newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.physics.box2d.World$2 -> com.badlogic.gdx.physics.box2d.p:
    com.badlogic.gdx.physics.box2d.World this$0 -> a
    com.badlogic.gdx.physics.box2d.Fixture newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.physics.box2d.WorldManifold -> com.badlogic.gdx.physics.box2d.q:
    com.badlogic.gdx.math.Vector2 normal -> a
    com.badlogic.gdx.math.Vector2[] points -> b
    float[] separations -> c
    int numContactPoints -> d
    com.badlogic.gdx.math.Vector2 getNormal() -> a
com.badlogic.gdx.scenes.scene2d.Action -> com.badlogic.gdx.f.a.a:
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    com.badlogic.gdx.utils.Pool pool -> b
    boolean act(float) -> a
    void restart() -> a
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void reset() -> b
    com.badlogic.gdx.utils.Pool getPool() -> c
    void setPool(com.badlogic.gdx.utils.Pool) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.Actor -> com.badlogic.gdx.f.a.b:
    com.badlogic.gdx.scenes.scene2d.Stage stage -> l
    com.badlogic.gdx.scenes.scene2d.Group parent -> a
    com.badlogic.gdx.utils.DelayedRemovalArray listeners -> m
    com.badlogic.gdx.utils.DelayedRemovalArray captureListeners -> n
    com.badlogic.gdx.utils.Array actions -> o
    java.lang.String name -> p
    com.badlogic.gdx.scenes.scene2d.Touchable touchable -> q
    boolean visible -> r
    boolean debug -> s
    float x -> b
    float y -> c
    float width -> d
    float height -> e
    float originX -> f
    float originY -> g
    float scaleX -> h
    float scaleY -> i
    float rotation -> j
    com.badlogic.gdx.graphics.Color color -> k
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void act(float) -> a
    boolean fire(com.badlogic.gdx.scenes.scene2d.Event) -> a
    boolean notify(com.badlogic.gdx.scenes.scene2d.Event,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    boolean remove() -> a
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
    boolean addCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> b
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.utils.Array getActions() -> b
    void clearActions() -> c
    void clearListeners() -> d
    void clear() -> e
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> f
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    boolean isDescendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.Group getParent() -> g
    void setParent(com.badlogic.gdx.scenes.scene2d.Group) -> a
    boolean isTouchable() -> h
    com.badlogic.gdx.scenes.scene2d.Touchable getTouchable() -> i
    void setTouchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> a
    boolean isVisible() -> j
    void setVisible(boolean) -> a
    float getX() -> k
    float getY() -> l
    void setPosition(float,float) -> a
    float getCenterX() -> m
    void moveBy(float,float) -> b
    float getWidth() -> n
    void setWidth(float) -> b
    float getHeight() -> o
    void setHeight(float) -> c
    void positionChanged() -> p
    void sizeChanged() -> q
    void setSize(float,float) -> c
    void setBounds(float,float,float,float) -> a
    float getOriginX() -> r
    float getOriginY() -> s
    void setOrigin(float,float) -> d
    float getScaleX() -> t
    float getScaleY() -> u
    void setScale(float) -> d
    void scaleBy(float,float) -> e
    float getRotation() -> v
    void setRotation(float) -> e
    com.badlogic.gdx.graphics.Color getColor() -> w
    java.lang.String getName() -> x
    void setName(java.lang.String) -> a
    boolean clipBegin(float,float,float,float) -> b
    void clipEnd() -> y
    com.badlogic.gdx.math.Vector2 stageToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 parentToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> b
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> b
    void setDebug(boolean) -> b
    boolean getDebug() -> z
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.Event -> com.badlogic.gdx.f.a.c:
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> c
    boolean capture -> d
    boolean bubbles -> e
    boolean handled -> f
    boolean stopped -> g
    boolean cancelled -> h
    void handle() -> a
    void stop() -> c
    void reset() -> b
    com.badlogic.gdx.scenes.scene2d.Actor getTarget() -> d
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getListenerActor() -> e
    void setListenerActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean getBubbles() -> f
    boolean isHandled() -> g
    boolean isStopped() -> h
    boolean isCancelled() -> i
    void setCapture(boolean) -> a
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> j
com.badlogic.gdx.scenes.scene2d.EventListener -> com.badlogic.gdx.f.a.d:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.Group -> com.badlogic.gdx.f.a.e:
    com.badlogic.gdx.math.Vector2 tmp -> n
    com.badlogic.gdx.utils.SnapshotArray children -> l
    com.badlogic.gdx.math.Matrix3 localTransform -> o
    com.badlogic.gdx.math.Matrix3 worldTransform -> p
    com.badlogic.gdx.math.Matrix4 computedTransform -> q
    com.badlogic.gdx.math.Matrix4 oldTransform -> r
    boolean transform -> m
    com.badlogic.gdx.math.Rectangle cullingArea -> s
    void act(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawChildren(com.badlogic.gdx.graphics.g2d.Batch,float) -> b
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    void drawDebugChildren(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> c
    com.badlogic.gdx.math.Matrix4 computeTransform() -> A
    void applyTransform(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.math.Matrix4) -> a
    void resetTransform(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void applyTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer,com.badlogic.gdx.math.Matrix4) -> a
    void resetTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> d
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void childrenChanged() -> B
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void clearChildren() -> C
    void clear() -> e
    com.badlogic.gdx.scenes.scene2d.Actor findActor(java.lang.String) -> b
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    com.badlogic.gdx.utils.SnapshotArray getChildren() -> D
    void setTransform(boolean) -> c
    boolean isTransform() -> f_
    void setDebug(boolean,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> F
com.badlogic.gdx.scenes.scene2d.InputEvent -> com.badlogic.gdx.f.a.f:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type type -> a
    float stageX -> b
    float stageY -> c
    int pointer -> d
    int button -> e
    int keyCode -> f
    int scrollAmount -> g
    char character -> h
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> i
    void reset() -> b
    float getStageX() -> k
    void setStageX(float) -> a
    float getStageY() -> l
    void setStageY(float) -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type getType() -> m
    void setType(com.badlogic.gdx.scenes.scene2d.InputEvent$Type) -> a
    int getPointer() -> n
    void setPointer(int) -> a
    int getButton() -> o
    void setButton(int) -> b
    int getKeyCode() -> p
    void setKeyCode(int) -> c
    char getCharacter() -> q
    void setCharacter(char) -> a
    int getScrollAmount() -> r
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> s
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    com.badlogic.gdx.math.Vector2 toCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> a
    boolean isTouchFocusCancel() -> t
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.InputEvent$Type -> com.badlogic.gdx.f.a.g:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDown -> a
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchUp -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDragged -> c
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type mouseMoved -> d
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type enter -> e
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type exit -> f
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type scrolled -> g
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyDown -> h
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyUp -> i
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyTyped -> j
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] $VALUES -> k
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] values() -> values
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.InputListener -> com.badlogic.gdx.f.a.h:
    com.badlogic.gdx.math.Vector2 tmpCoords -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
com.badlogic.gdx.scenes.scene2d.InputListener$1 -> com.badlogic.gdx.f.a.i:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.Stage -> com.badlogic.gdx.f.a.j:
    com.badlogic.gdx.math.Vector2 actorCoords -> b
    boolean debug -> a
    com.badlogic.gdx.utils.viewport.Viewport viewport -> c
    com.badlogic.gdx.graphics.g2d.Batch batch -> d
    boolean ownsBatch -> e
    com.badlogic.gdx.scenes.scene2d.Group root -> f
    com.badlogic.gdx.math.Vector2 stageCoords -> g
    com.badlogic.gdx.scenes.scene2d.Actor[] pointerOverActors -> h
    boolean[] pointerTouched -> i
    int[] pointerScreenX -> j
    int[] pointerScreenY -> k
    int mouseScreenX -> l
    int mouseScreenY -> m
    com.badlogic.gdx.scenes.scene2d.Actor mouseOverActor -> n
    com.badlogic.gdx.scenes.scene2d.Actor keyboardFocus -> o
    com.badlogic.gdx.scenes.scene2d.Actor scrollFocus -> p
    com.badlogic.gdx.utils.SnapshotArray touchFocuses -> q
    com.badlogic.gdx.graphics.glutils.ShapeRenderer debugShapes -> r
    boolean debugAll -> s
    boolean debugUnderMouse -> t
    boolean debugParentUnderMouse -> u
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debugTableUnderMouse -> v
    com.badlogic.gdx.graphics.Color debugColor -> w
    void draw() -> a
    void drawDebug() -> k
    void disableDebug(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void act(float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor fireEnterAndExit(com.badlogic.gdx.scenes.scene2d.Actor,int,int,int) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchDragged(int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    void addTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor,int,int) -> a
    void cancelTouchFocus() -> b
    void cancelTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void clear() -> d
    void unfocusAll() -> e
    void unfocus(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void setScrollFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    com.badlogic.gdx.utils.viewport.Viewport getViewport() -> f
    float getWidth() -> g
    float getHeight() -> h
    com.badlogic.gdx.scenes.scene2d.Group getRoot() -> i
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    com.badlogic.gdx.math.Vector2 screenToStageCoordinates(com.badlogic.gdx.math.Vector2) -> a
    void calculateScissors(com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.graphics.Color getDebugColor() -> j
    void dispose() -> c
com.badlogic.gdx.scenes.scene2d.Stage$TouchFocus -> com.badlogic.gdx.f.a.k:
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> a
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> b
    com.badlogic.gdx.scenes.scene2d.Actor target -> c
    int pointer -> d
    int button -> e
    void reset() -> b
com.badlogic.gdx.scenes.scene2d.Touchable -> com.badlogic.gdx.f.a.l:
    com.badlogic.gdx.scenes.scene2d.Touchable enabled -> a
    com.badlogic.gdx.scenes.scene2d.Touchable disabled -> b
    com.badlogic.gdx.scenes.scene2d.Touchable childrenOnly -> c
    com.badlogic.gdx.scenes.scene2d.Touchable[] $VALUES -> d
    com.badlogic.gdx.scenes.scene2d.Touchable[] values() -> values
    com.badlogic.gdx.scenes.scene2d.Touchable valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.actions.AlphaAction -> com.badlogic.gdx.f.a.a.a:
    float start -> b
    float end -> c
    com.badlogic.gdx.graphics.Color color -> d
    void begin() -> d
    void update(float) -> b
    void reset() -> b
    void setAlpha(float) -> c
com.badlogic.gdx.scenes.scene2d.actions.DelayAction -> com.badlogic.gdx.f.a.a.b:
    float duration -> c
    float time -> d
    boolean delegate(float) -> b
    void restart() -> a
com.badlogic.gdx.scenes.scene2d.actions.DelegateAction -> com.badlogic.gdx.f.a.a.c:
    com.badlogic.gdx.scenes.scene2d.Action action -> b
    boolean delegate(float) -> b
    boolean act(float) -> a
    void restart() -> a
    void reset() -> b
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.actions.MoveByAction -> com.badlogic.gdx.f.a.a.d:
    float amountX -> b
    float amountY -> c
    void updateRelative(float) -> c
    void setAmount(float,float) -> a
com.badlogic.gdx.scenes.scene2d.actions.ParallelAction -> com.badlogic.gdx.f.a.a.e:
    com.badlogic.gdx.utils.Array actions -> b
    boolean complete -> c
    boolean act(float) -> a
    void restart() -> a
    void reset() -> b
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.actions.RelativeTemporalAction -> com.badlogic.gdx.f.a.a.f:
    float lastPercent -> b
    void begin() -> d
    void update(float) -> b
    void updateRelative(float) -> c
com.badlogic.gdx.scenes.scene2d.actions.RotateToAction -> com.badlogic.gdx.f.a.a.g:
    float start -> b
    float end -> c
    void begin() -> d
    void update(float) -> b
    void setRotation(float) -> c
com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction -> com.badlogic.gdx.f.a.a.h:
    float amountX -> b
    float amountY -> c
    void updateRelative(float) -> c
    void setAmount(float) -> d
com.badlogic.gdx.scenes.scene2d.actions.SequenceAction -> com.badlogic.gdx.f.a.a.i:
    int index -> c
    boolean act(float) -> a
    void restart() -> a
com.badlogic.gdx.scenes.scene2d.actions.TemporalAction -> com.badlogic.gdx.f.a.a.j:
    float duration -> b
    float time -> c
    com.badlogic.gdx.math.Interpolation interpolation -> d
    boolean reverse -> e
    boolean began -> f
    boolean complete -> g
    boolean act(float) -> a
    void begin() -> d
    void end() -> e
    void update(float) -> b
    void restart() -> a
    void reset() -> b
    void setDuration(float) -> e
    void setInterpolation(com.badlogic.gdx.math.Interpolation) -> a
com.badlogic.gdx.scenes.scene2d.ui.Button -> com.badlogic.gdx.f.a.b.a:
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle style -> C
    boolean isChecked -> n
    boolean isDisabled -> o
    com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup buttonGroup -> p
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> D
    void initialize() -> Y
    void setChecked(boolean) -> d
    boolean isChecked() -> a_
    boolean isPressed() -> b_
    boolean isOver() -> c_
    boolean isDisabled() -> J
    void setDisabled(boolean) -> e
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    float getPrefWidth() -> K
    float getPrefHeight() -> L
    float getMinWidth() -> M
    float getMinHeight() -> N
com.badlogic.gdx.scenes.scene2d.ui.Button$1 -> com.badlogic.gdx.f.a.b.b:
    com.badlogic.gdx.scenes.scene2d.ui.Button this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle -> com.badlogic.gdx.f.a.b.c:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable up -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checked -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedOver -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabled -> f
    float pressedOffsetX -> g
    float pressedOffsetY -> h
    float unpressedOffsetX -> i
    float unpressedOffsetY -> j
com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup -> com.badlogic.gdx.f.a.b.d:
    com.badlogic.gdx.utils.Array checkedButtons -> a
    int minCheckCount -> b
    int maxCheckCount -> c
    boolean uncheckLast -> d
    com.badlogic.gdx.scenes.scene2d.ui.Button lastChecked -> e
    boolean canCheck(com.badlogic.gdx.scenes.scene2d.ui.Button,boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.Cell -> com.badlogic.gdx.f.a.b.e:
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> b
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> c
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> d
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> e
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> f
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceTop -> g
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceLeft -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceBottom -> i
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceRight -> j
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> k
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> l
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> m
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> n
    java.lang.Float fillX -> o
    java.lang.Float fillY -> p
    java.lang.Integer align -> q
    java.lang.Integer expandX -> r
    java.lang.Integer expandY -> s
    java.lang.Integer colspan -> t
    java.lang.Boolean uniformX -> u
    java.lang.Boolean uniformY -> v
    com.badlogic.gdx.scenes.scene2d.Actor actor -> w
    float actorX -> x
    float actorY -> y
    float actorWidth -> z
    float actorHeight -> A
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> J
    boolean endRow -> B
    int column -> C
    int row -> D
    int cellAboveIndex -> E
    float computedPadTop -> F
    float computedPadLeft -> G
    float computedPadBottom -> H
    float computedPadRight -> I
    void setLayout(com.badlogic.gdx.scenes.scene2d.ui.Table) -> a
    void set(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> a
    void merge(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell width(com.badlogic.gdx.scenes.scene2d.ui.Value) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell width(float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell space(float) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell pad(float,float,float,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell padTop(float) -> c
    com.badlogic.gdx.scenes.scene2d.ui.Cell padLeft(float) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell padBottom(float) -> e
    com.badlogic.gdx.scenes.scene2d.ui.Cell padRight(float) -> f
    com.badlogic.gdx.scenes.scene2d.ui.Cell fill() -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell center() -> c
    com.badlogic.gdx.scenes.scene2d.ui.Cell top() -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell left() -> e
    com.badlogic.gdx.scenes.scene2d.ui.Cell expand() -> f
    void setActorBounds(float,float,float,float) -> b
    void setActorY(float) -> g
    void clear() -> g
    void reset() -> b
    void defaults() -> h
com.badlogic.gdx.scenes.scene2d.ui.Image -> com.badlogic.gdx.f.a.b.f:
    com.badlogic.gdx.utils.Scaling scaling -> l
    int align -> m
    float imageX -> n
    float imageY -> o
    float imageWidth -> p
    float imageHeight -> q
    com.badlogic.gdx.scenes.scene2d.utils.Drawable drawable -> r
    void layout() -> A
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    float getMinWidth() -> M
    float getMinHeight() -> N
    float getPrefWidth() -> K
    float getPrefHeight() -> L
com.badlogic.gdx.scenes.scene2d.ui.Label -> com.badlogic.gdx.f.a.b.g:
    com.badlogic.gdx.graphics.Color tempColor -> l
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle style -> m
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds bounds -> n
    com.badlogic.gdx.utils.StringBuilder text -> o
    com.badlogic.gdx.utils.StringBuilder tempText -> p
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> q
    int labelAlign -> r
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment lineAlign -> s
    boolean wrap -> t
    float lastPrefHeight -> u
    boolean sizeInvalid -> v
    float fontScaleX -> w
    float fontScaleY -> x
    boolean ellipse -> y
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> a
    void setText(java.lang.CharSequence) -> a
    boolean textEquals(java.lang.CharSequence) -> b
    com.badlogic.gdx.utils.StringBuilder getText() -> B
    void invalidate() -> C
    void scaleAndComputeSize() -> F
    void computeSize() -> G
    void layout() -> A
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    float getPrefWidth() -> K
    float getPrefHeight() -> L
    void setAlignment(int) -> a
    void setAlignment(int,int) -> a
    void setFontScale(float) -> f
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle -> com.badlogic.gdx.f.a.b.h:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColor -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> c
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane -> com.badlogic.gdx.f.a.b.i:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle style -> R
    com.badlogic.gdx.scenes.scene2d.Actor widget -> S
    com.badlogic.gdx.math.Rectangle hScrollBounds -> n
    com.badlogic.gdx.math.Rectangle vScrollBounds -> o
    com.badlogic.gdx.math.Rectangle hKnobBounds -> p
    com.badlogic.gdx.math.Rectangle vKnobBounds -> q
    com.badlogic.gdx.math.Rectangle widgetAreaBounds -> T
    com.badlogic.gdx.math.Rectangle widgetCullingArea -> U
    com.badlogic.gdx.math.Rectangle scissorBounds -> V
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener flickScrollListener -> W
    boolean scrollX -> r
    boolean scrollY -> s
    boolean vScrollOnRight -> t
    boolean hScrollOnBottom -> u
    float amountX -> v
    float amountY -> w
    float visualAmountX -> x
    float visualAmountY -> y
    float maxX -> z
    float maxY -> A
    boolean touchScrollH -> B
    boolean touchScrollV -> C
    com.badlogic.gdx.math.Vector2 lastPoint -> D
    float areaWidth -> E
    float areaHeight -> F
    boolean fadeScrollBars -> X
    boolean smoothScrolling -> Y
    float fadeAlpha -> G
    float fadeAlphaSeconds -> H
    float fadeDelay -> I
    float fadeDelaySeconds -> J
    boolean cancelTouchFocus -> K
    boolean flickScroll -> L
    float velocityX -> M
    float velocityY -> N
    float flingTimer -> O
    boolean overscrollX -> Z
    boolean overscrollY -> aa
    float flingTime -> P
    float overscrollDistance -> ab
    float overscrollSpeedMin -> ac
    float overscrollSpeedMax -> ad
    boolean forceScrollX -> ae
    boolean forceScrollY -> af
    boolean disableX -> ag
    boolean disableY -> ah
    boolean clamp -> ai
    boolean scrollbarsOnTop -> aj
    boolean variableSizeKnobs -> ak
    int draggingPointer -> Q
    void resetFade() -> g_
    void cancelTouchFocusedChild(com.badlogic.gdx.scenes.scene2d.InputEvent) -> a
    void cancel() -> H
    void clamp() -> I
    void act(float) -> a
    void layout() -> d_
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    float getPrefWidth() -> K
    float getPrefHeight() -> L
    float getMinWidth() -> M
    float getMinHeight() -> N
    void setWidget(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void scrollX(float) -> f
    void scrollY(float) -> g
    void visualScrollX(float) -> h
    void visualScrollY(float) -> i
    float getMouseWheelX() -> O
    float getMouseWheelY() -> P
    void setScrollX(float) -> j
    float getScrollX() -> Q
    void setScrollY(float) -> k
    float getVisualScrollPercentX() -> R
    float getVisualScrollPercentY() -> S
    float getScrollPercentX() -> T
    void setScrollPercentX(float) -> l
    float getScrollPercentY() -> U
    void setScrollPercentY(float) -> m
    float getMaxX() -> V
    void setScrollingDisabled(boolean,boolean) -> b
    boolean isDragging() -> W
    boolean isPanning() -> X
    boolean isFlinging() -> Y
    void setFlingTime(float) -> n
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$1 -> com.badlogic.gdx.f.a.b.j:
    float handlePosition -> b
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$2 -> com.badlogic.gdx.f.a.b.k:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> a
    void pan(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> a
    void fling(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$3 -> com.badlogic.gdx.f.a.b.l:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> a
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> b
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle -> com.badlogic.gdx.f.a.b.m:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable corner -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable hScroll -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable hScrollKnob -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable vScroll -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable vScrollKnob -> f
com.badlogic.gdx.scenes.scene2d.ui.Skin -> com.badlogic.gdx.f.a.b.n:
    com.badlogic.gdx.utils.ObjectMap resources -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas atlas -> b
    void load(com.badlogic.gdx.files.FileHandle) -> a
    void addRegions(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> a
    void add(java.lang.String,java.lang.Object) -> a
    void add(java.lang.String,java.lang.Object,java.lang.Class) -> a
    java.lang.Object get(java.lang.Class) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    java.lang.Object optional(java.lang.String,java.lang.Class) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont(java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion(java.lang.String) -> b
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch(java.lang.String) -> c
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(java.lang.String) -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable(java.lang.String) -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String,com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas getAtlas() -> a
    void dispose() -> c
    com.badlogic.gdx.utils.Json getJsonLoader(com.badlogic.gdx.files.FileHandle) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$1 -> com.badlogic.gdx.f.a.b.o:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$2 -> com.badlogic.gdx.f.a.b.p:
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    void readNamedObjects(com.badlogic.gdx.utils.Json,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$3 -> com.badlogic.gdx.f.a.b.q:
    com.badlogic.gdx.files.FileHandle val$skinFile -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$4 -> com.badlogic.gdx.f.a.b.r:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    com.badlogic.gdx.graphics.Color read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$5 -> com.badlogic.gdx.f.a.b.s:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable -> com.badlogic.gdx.f.a.b.t:
com.badlogic.gdx.scenes.scene2d.ui.Stack -> com.badlogic.gdx.f.a.b.u:
    float prefWidth -> n
    float prefHeight -> o
    float minWidth -> p
    float minHeight -> q
    float maxWidth -> r
    float maxHeight -> s
    boolean sizeInvalid -> t
    void invalidate() -> G
    void computeSize() -> O
    void add(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    void layout() -> d_
    float getPrefWidth() -> K
    float getPrefHeight() -> L
    float getMinWidth() -> M
    float getMinHeight() -> N
    float getMaxWidth() -> h_
    float getMaxHeight() -> i_
com.badlogic.gdx.scenes.scene2d.ui.Table -> com.badlogic.gdx.f.a.b.v:
    com.badlogic.gdx.graphics.Color debugTableColor -> q
    com.badlogic.gdx.graphics.Color debugCellColor -> r
    com.badlogic.gdx.graphics.Color debugActorColor -> s
    com.badlogic.gdx.utils.Pool cellPool -> t
    float[] columnWeightedWidth -> n
    float[] rowWeightedHeight -> o
    int columns -> p
    int rows -> C
    com.badlogic.gdx.utils.Array cells -> D
    com.badlogic.gdx.scenes.scene2d.ui.Cell cellDefaults -> E
    com.badlogic.gdx.utils.Array columnDefaults -> F
    com.badlogic.gdx.scenes.scene2d.ui.Cell rowDefaults -> G
    boolean sizeInvalid -> H
    float[] columnMinWidth -> I
    float[] rowMinHeight -> J
    float[] columnPrefWidth -> K
    float[] rowPrefHeight -> L
    float tableMinWidth -> M
    float tableMinHeight -> N
    float tablePrefWidth -> O
    float tablePrefHeight -> P
    float[] columnWidth -> Q
    float[] rowHeight -> R
    float[] expandWidth -> S
    float[] expandHeight -> T
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> u
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> v
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> w
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> x
    int align -> y
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debug -> z
    com.badlogic.gdx.utils.Array debugRects -> A
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> U
    boolean clip -> V
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> W
    boolean round -> B
    com.badlogic.gdx.scenes.scene2d.ui.Cell obtainCell() -> Y
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float,float,float) -> a
    void setBackground(com.badlogic.gdx.scenes.scene2d.utils.Drawable,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void invalidate() -> G
    com.badlogic.gdx.scenes.scene2d.ui.Cell add(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell add() -> O
    com.badlogic.gdx.scenes.scene2d.ui.Cell stack(com.badlogic.gdx.scenes.scene2d.Actor[]) -> a
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void clearChildren() -> C
    com.badlogic.gdx.scenes.scene2d.ui.Cell row() -> P
    void endRow() -> Z
    com.badlogic.gdx.scenes.scene2d.ui.Cell getCell(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    com.badlogic.gdx.utils.Array getCells() -> Q
    float getPrefWidth() -> K
    float getPrefHeight() -> L
    float getMinWidth() -> M
    float getMinHeight() -> N
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults() -> R
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(com.badlogic.gdx.scenes.scene2d.ui.Value) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(float,float,float,float) -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table padTop(float) -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table padLeft(float) -> g
    com.badlogic.gdx.scenes.scene2d.ui.Table padBottom(float) -> h
    com.badlogic.gdx.scenes.scene2d.ui.Table padRight(float) -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table center() -> S
    com.badlogic.gdx.scenes.scene2d.ui.Table top() -> T
    com.badlogic.gdx.scenes.scene2d.ui.Table left() -> U
    com.badlogic.gdx.scenes.scene2d.ui.Table bottom() -> V
    com.badlogic.gdx.scenes.scene2d.ui.Table right() -> W
    void setDebug(boolean) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Table debugAll() -> X
    com.badlogic.gdx.scenes.scene2d.ui.Table debug(com.badlogic.gdx.scenes.scene2d.ui.Table$Debug) -> a
    float[] ensureSize(float[],int) -> a
    void layout() -> d_
    void computeSize() -> aa
    void layout(float,float,float,float) -> d
    void clearDebugRects() -> ab
    void addDebugRect(float,float,float,float,com.badlogic.gdx.graphics.Color) -> a
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> b
    void drawDebugRects(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> e
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> F
com.badlogic.gdx.scenes.scene2d.ui.Table$1 -> com.badlogic.gdx.f.a.b.w:
    com.badlogic.gdx.scenes.scene2d.ui.Cell newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.scenes.scene2d.ui.Table$Debug -> com.badlogic.gdx.f.a.b.x:
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug none -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug all -> b
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug table -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug cell -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug actor -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug[] $VALUES -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug[] values() -> values
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.ui.Table$DebugRect -> com.badlogic.gdx.f.a.b.y:
    com.badlogic.gdx.utils.Pool pool -> g
    com.badlogic.gdx.graphics.Color color -> h
com.badlogic.gdx.scenes.scene2d.ui.Value -> com.badlogic.gdx.f.a.b.z:
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed zero -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> b
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> c
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> d
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> e
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> f
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> g
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$1 -> com.badlogic.gdx.f.a.b.aa:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$2 -> com.badlogic.gdx.f.a.b.ab:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$3 -> com.badlogic.gdx.f.a.b.ac:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$4 -> com.badlogic.gdx.f.a.b.ad:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$5 -> com.badlogic.gdx.f.a.b.ae:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$6 -> com.badlogic.gdx.f.a.b.af:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed -> com.badlogic.gdx.f.a.b.ag:
    float value -> h
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Widget -> com.badlogic.gdx.f.a.b.ah:
    boolean needsLayout -> l
    boolean fillParent -> m
    boolean layoutEnabled -> n
    float getMinWidth() -> M
    float getMinHeight() -> N
    float getPrefWidth() -> K
    float getPrefHeight() -> L
    float getMaxWidth() -> h_
    float getMaxHeight() -> i_
    void validate() -> e_
    void invalidate() -> C
    void invalidateHierarchy() -> E
    void sizeChanged() -> q
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void layout() -> A
com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup -> com.badlogic.gdx.f.a.b.ai:
    boolean needsLayout -> n
    boolean fillParent -> o
    boolean layoutEnabled -> p
    float getMinWidth() -> M
    float getMinHeight() -> N
    float getPrefWidth() -> K
    float getPrefHeight() -> L
    float getMaxWidth() -> h_
    float getMaxHeight() -> i_
    void validate() -> e_
    void invalidate() -> G
    void invalidateHierarchy() -> E
    void childrenChanged() -> B
    void sizeChanged() -> q
    void setFillParent(boolean) -> f
    void layout() -> d_
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener -> com.badlogic.gdx.f.a.c.a:
    com.badlogic.gdx.math.Vector2 tmpCoords -> b
    com.badlogic.gdx.input.GestureDetector detector -> a
    com.badlogic.gdx.scenes.scene2d.InputEvent event -> c
    com.badlogic.gdx.scenes.scene2d.Actor actor -> d
    com.badlogic.gdx.scenes.scene2d.Actor touchDownTarget -> e
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void tap(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> c
    boolean longPress(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> a
    void fling(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void pan(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> a
    void zoom(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    void pinch(com.badlogic.gdx.scenes.scene2d.InputEvent,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.input.GestureDetector getGestureDetector() -> a
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener$1 -> com.badlogic.gdx.f.a.c.b:
    com.badlogic.gdx.math.Vector2 initialPointer1 -> b
    com.badlogic.gdx.math.Vector2 initialPointer2 -> c
    com.badlogic.gdx.math.Vector2 pointer1 -> d
    com.badlogic.gdx.math.Vector2 pointer2 -> e
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener this$0 -> a
    boolean tap(float,float,int,int) -> b
    boolean longPress(float,float) -> a
    boolean fling(float,float,int) -> a
    boolean pan(float,float,float,float) -> a
    boolean zoom(float,float) -> b
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener$2 -> com.badlogic.gdx.f.a.c.c:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable -> com.badlogic.gdx.f.a.c.d:
    float leftWidth -> a
    float rightWidth -> b
    float topHeight -> c
    float bottomHeight -> d
    float minWidth -> e
    float minHeight -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getLeftWidth() -> a
    void setLeftWidth(float) -> a
    float getRightWidth() -> b
    void setRightWidth(float) -> b
    float getTopHeight() -> c
    void setTopHeight(float) -> c
    float getBottomHeight() -> d
    void setBottomHeight(float) -> d
    float getMinWidth() -> e
    void setMinWidth(float) -> e
    float getMinHeight() -> f
    void setMinHeight(float) -> f
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener -> com.badlogic.gdx.f.a.c.e:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent -> com.badlogic.gdx.f.a.c.f:
com.badlogic.gdx.scenes.scene2d.utils.ClickListener -> com.badlogic.gdx.f.a.c.g:
    float visualPressedDuration -> b
    float tapSquareSize -> a
    float touchDownX -> c
    float touchDownY -> d
    int pressedPointer -> e
    int pressedButton -> f
    int button -> g
    boolean pressed -> h
    boolean over -> i
    boolean cancelled -> j
    float visualPressedTime -> k
    long tapCountInterval -> l
    int tapCount -> m
    long lastTapTime -> n
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
    boolean isOver(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> a
    boolean inTapSquare(float,float) -> a
    void invalidateTapSquare() -> a
    boolean isVisualPressed() -> b
    boolean isOver() -> c
com.badlogic.gdx.scenes.scene2d.utils.Cullable -> com.badlogic.gdx.f.a.c.h:
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.scenes.scene2d.utils.Drawable -> com.badlogic.gdx.f.a.c.i:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getLeftWidth() -> a
    float getRightWidth() -> b
    float getTopHeight() -> c
    float getBottomHeight() -> d
    float getMinWidth() -> e
    float getMinHeight() -> f
com.badlogic.gdx.scenes.scene2d.utils.FocusListener -> com.badlogic.gdx.f.a.c.j:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void keyboardFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    void scrollFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> b
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$1 -> com.badlogic.gdx.f.a.c.k:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$utils$FocusListener$FocusEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent -> com.badlogic.gdx.f.a.c.l:
    boolean focused -> a
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type type -> b
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> c
    void reset() -> b
    boolean isFocused() -> k
    void setFocused(boolean) -> b
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type getType() -> l
    void setType(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type) -> a
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type -> com.badlogic.gdx.f.a.c.m:
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type keyboard -> a
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type scroll -> b
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type[] $VALUES -> c
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type[] values() -> values
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.utils.Layout -> com.badlogic.gdx.f.a.c.n:
    void invalidateHierarchy() -> E
    void validate() -> e_
    float getMinWidth() -> M
    float getMinHeight() -> N
    float getPrefWidth() -> K
    float getPrefHeight() -> L
    float getMaxWidth() -> h_
    float getMaxHeight() -> i_
com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable -> com.badlogic.gdx.f.a.c.o:
    com.badlogic.gdx.graphics.g2d.NinePatch patch -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void setPatch(com.badlogic.gdx.graphics.g2d.NinePatch) -> a
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch() -> g
com.badlogic.gdx.scenes.scene2d.utils.ScissorStack -> com.badlogic.gdx.f.a.c.p:
    com.badlogic.gdx.utils.Array scissors -> c
    com.badlogic.gdx.math.Vector3 tmp -> a
    com.badlogic.gdx.math.Rectangle viewport -> b
    boolean pushScissors(com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.math.Rectangle popScissors() -> a
    void fix(com.badlogic.gdx.math.Rectangle) -> b
    void calculateScissors(com.badlogic.gdx.graphics.Camera,float,float,float,float,com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable -> com.badlogic.gdx.f.a.c.q:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    com.badlogic.gdx.graphics.g2d.Sprite getSprite() -> g
com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable -> com.badlogic.gdx.f.a.c.r:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> g
com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable -> com.badlogic.gdx.f.a.c.s:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable -> com.badlogic.gdx.f.a.c.t:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
com.badlogic.gdx.utils.Array -> com.badlogic.gdx.utils.a:
    java.lang.Object[] items -> a
    int size -> b
    boolean ordered -> c
    com.badlogic.gdx.utils.Array$ArrayIterable iterable -> d
    void add(java.lang.Object) -> a
    void addAll(com.badlogic.gdx.utils.Array) -> a
    void addAll(com.badlogic.gdx.utils.Array,int,int) -> a
    void addAll(java.lang.Object[],int,int) -> a
    java.lang.Object get(int) -> a
    void set(int,java.lang.Object) -> a
    boolean contains(java.lang.Object,boolean) -> a
    int indexOf(java.lang.Object,boolean) -> b
    boolean removeValue(java.lang.Object,boolean) -> c
    java.lang.Object removeIndex(int) -> b
    java.lang.Object pop() -> a
    java.lang.Object peek() -> b
    java.lang.Object first() -> c
    void clear() -> d
    java.lang.Object[] ensureCapacity(int) -> c
    java.lang.Object[] resize(int) -> d
    void sort(java.util.Comparator) -> a
    void reverse() -> e
    java.util.Iterator iterator() -> iterator
    java.lang.Object[] toArray(java.lang.Class) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.Array$ArrayIterable -> com.badlogic.gdx.utils.b:
    com.badlogic.gdx.utils.Array array -> a
    boolean allowRemove -> b
    com.badlogic.gdx.utils.Array$ArrayIterator iterator1 -> c
    com.badlogic.gdx.utils.Array$ArrayIterator iterator2 -> d
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.Array$ArrayIterator -> com.badlogic.gdx.utils.c:
    com.badlogic.gdx.utils.Array array -> c
    boolean allowRemove -> d
    int index -> a
    boolean valid -> b
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.ArrayMap -> com.badlogic.gdx.utils.d:
    java.lang.Object[] keys -> a
    java.lang.Object[] values -> b
    int size -> c
    boolean ordered -> d
    com.badlogic.gdx.utils.ArrayMap$Entries entries1 -> e
    com.badlogic.gdx.utils.ArrayMap$Entries entries2 -> f
    void put(java.lang.Object,java.lang.Object) -> a
    int indexOfKey(java.lang.Object) -> a
    void removeIndex(int) -> a
    void clear() -> a
    void resize(int) -> b
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ArrayMap$Entries entries() -> b
com.badlogic.gdx.utils.ArrayMap$Entries -> com.badlogic.gdx.utils.e:
    com.badlogic.gdx.utils.ArrayMap map -> d
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> a
    int index -> b
    boolean valid -> c
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
com.badlogic.gdx.utils.Base64Coder -> com.badlogic.gdx.utils.f:
    char[] map1 -> a
    byte[] map2 -> b
    java.lang.String encodeString(java.lang.String) -> a
    char[] encode(byte[]) -> a
    char[] encode(byte[],int,int) -> a
    java.lang.String decodeString(java.lang.String) -> b
    byte[] decode(java.lang.String) -> c
    byte[] decode(char[]) -> a
    byte[] decode(char[],int,int) -> a
com.badlogic.gdx.utils.BaseJsonReader -> com.badlogic.gdx.utils.g:
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.utils.BufferUtils -> com.badlogic.gdx.utils.BufferUtils:
    com.badlogic.gdx.utils.Array unsafeBuffers -> a
    int allocatedUnsafe -> b
    void copy(float[],java.nio.Buffer,int,int) -> a
    java.nio.FloatBuffer newFloatBuffer(int) -> a
    java.nio.ByteBuffer newByteBuffer(int) -> b
    java.nio.IntBuffer newIntBuffer(int) -> c
    void disposeUnsafeByteBuffer(java.nio.ByteBuffer) -> a
    java.nio.ByteBuffer newUnsafeByteBuffer(int) -> d
    void freeMemory(java.nio.ByteBuffer) -> freeMemory
    java.nio.ByteBuffer newDisposableByteBuffer(int) -> newDisposableByteBuffer
    void copyJni(float[],java.nio.Buffer,int,int) -> copyJni
com.badlogic.gdx.utils.DelayedRemovalArray -> com.badlogic.gdx.utils.h:
    int iterating -> d
    com.badlogic.gdx.utils.IntArray remove -> e
    void begin() -> f
    void end() -> g
    void remove(int) -> e
    boolean removeValue(java.lang.Object,boolean) -> c
    java.lang.Object removeIndex(int) -> b
    void set(int,java.lang.Object) -> a
    java.lang.Object pop() -> a
    void clear() -> d
    void sort(java.util.Comparator) -> a
    void reverse() -> e
com.badlogic.gdx.utils.Disposable -> com.badlogic.gdx.utils.i:
    void dispose() -> c
com.badlogic.gdx.utils.FloatArray -> com.badlogic.gdx.utils.j:
    float[] items -> a
    int size -> b
    boolean ordered -> c
    void add(float) -> a
    float get(int) -> a
    void clear() -> a
    float[] resize(int) -> b
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.GdxNativesLoader -> com.badlogic.gdx.utils.k:
    boolean disableNativesLoading -> a
    boolean nativesLoaded -> b
    void load() -> a
com.badlogic.gdx.utils.GdxRuntimeException -> com.badlogic.gdx.utils.l:
com.badlogic.gdx.utils.I18NBundle -> com.badlogic.gdx.utils.m:
    boolean simpleFormatter -> a
    com.badlogic.gdx.utils.I18NBundle parent -> b
    java.util.Locale locale -> c
    com.badlogic.gdx.utils.ObjectMap properties -> d
    com.badlogic.gdx.utils.TextFormatter formatter -> e
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> a
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> a
    com.badlogic.gdx.utils.I18NBundle createBundleImpl(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> b
    java.util.List getCandidateLocales(java.util.Locale) -> a
    java.util.Locale getFallbackLocale(java.util.Locale) -> b
    com.badlogic.gdx.utils.I18NBundle loadBundleChain(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.List,int,com.badlogic.gdx.utils.I18NBundle) -> a
    com.badlogic.gdx.utils.I18NBundle loadBundle(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.Locale) -> a
    void load(java.io.Reader) -> a
    com.badlogic.gdx.files.FileHandle toFileHandle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> b
    java.util.Locale getLocale() -> a
    void setLocale(java.util.Locale) -> c
com.badlogic.gdx.utils.IntArray -> com.badlogic.gdx.utils.n:
    int[] items -> a
    int size -> b
    boolean ordered -> c
    void add(int) -> a
    int get(int) -> b
    void insert(int,int) -> a
    int removeIndex(int) -> c
    int pop() -> a
    void clear() -> b
    int[] ensureCapacity(int) -> d
    int[] resize(int) -> e
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.Json -> com.badlogic.gdx.utils.o:
    com.badlogic.gdx.utils.JsonWriter writer -> a
    java.lang.String typeName -> b
    boolean usePrototypes -> c
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> d
    com.badlogic.gdx.utils.ObjectMap typeToFields -> e
    com.badlogic.gdx.utils.ObjectMap tagToClass -> f
    com.badlogic.gdx.utils.ObjectMap classToTag -> g
    com.badlogic.gdx.utils.ObjectMap classToSerializer -> h
    com.badlogic.gdx.utils.ObjectMap classToDefaultValues -> i
    com.badlogic.gdx.utils.Json$Serializer defaultSerializer -> j
    boolean ignoreUnknownFields -> k
    void setTypeName(java.lang.String) -> a
    void setSerializer(java.lang.Class,com.badlogic.gdx.utils.Json$Serializer) -> a
    void setUsePrototypes(boolean) -> a
    com.badlogic.gdx.utils.ObjectMap cacheFields(java.lang.Class) -> c
    java.lang.String toJson(java.lang.Object) -> a
    java.lang.String toJson(java.lang.Object,java.lang.Class,java.lang.Class) -> a
    void toJson(java.lang.Object,java.lang.Class,java.lang.Class,java.io.Writer) -> a
    void setWriter(java.io.Writer) -> a
    void writeFields(java.lang.Object) -> b
    java.lang.Object[] getDefaultValues(java.lang.Class) -> d
    void writeValue(java.lang.String,java.lang.Object) -> a
    void writeValue(java.lang.Object,java.lang.Class,java.lang.Class) -> b
    void writeObjectStart(java.lang.Class,java.lang.Class) -> a
    void writeObjectEnd() -> a
    void writeArrayStart() -> b
    void writeArrayEnd() -> c
    void writeType(java.lang.Class) -> a
    java.lang.Object fromJson(java.lang.Class,com.badlogic.gdx.files.FileHandle) -> a
    java.lang.Object fromJson(java.lang.Class,java.lang.String) -> a
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.String convertToString(java.lang.Object) -> c
    java.lang.Object newInstance(java.lang.Class) -> b
com.badlogic.gdx.utils.Json$FieldMetadata -> com.badlogic.gdx.utils.p:
    com.badlogic.gdx.utils.reflect.Field field -> a
    java.lang.Class elementType -> b
com.badlogic.gdx.utils.Json$ReadOnlySerializer -> com.badlogic.gdx.utils.q:
    void write(com.badlogic.gdx.utils.Json,java.lang.Object,java.lang.Class) -> a
com.badlogic.gdx.utils.Json$Serializable -> com.badlogic.gdx.utils.r:
    void write(com.badlogic.gdx.utils.Json) -> a
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.utils.Json$Serializer -> com.badlogic.gdx.utils.s:
    void write(com.badlogic.gdx.utils.Json,java.lang.Object,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.utils.JsonReader -> com.badlogic.gdx.utils.t:
    byte[] _json_actions -> a
    short[] _json_key_offsets -> b
    char[] _json_trans_keys -> c
    byte[] _json_single_lengths -> d
    byte[] _json_range_lengths -> e
    short[] _json_index_offsets -> f
    byte[] _json_indicies -> g
    byte[] _json_trans_targs -> h
    byte[] _json_trans_actions -> i
    byte[] _json_eof_actions -> j
    com.badlogic.gdx.utils.Array elements -> k
    com.badlogic.gdx.utils.Array lastChild -> l
    com.badlogic.gdx.utils.JsonValue root -> m
    com.badlogic.gdx.utils.JsonValue current -> n
    com.badlogic.gdx.utils.JsonValue parse(java.lang.String) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.Reader) -> a
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.JsonValue parse(char[],int,int) -> a
    byte[] init__json_actions_0() -> b
    short[] init__json_key_offsets_0() -> c
    char[] init__json_trans_keys_0() -> d
    byte[] init__json_single_lengths_0() -> e
    byte[] init__json_range_lengths_0() -> f
    short[] init__json_index_offsets_0() -> g
    byte[] init__json_indicies_0() -> h
    byte[] init__json_trans_targs_0() -> i
    byte[] init__json_trans_actions_0() -> j
    byte[] init__json_eof_actions_0() -> k
    void addChild(java.lang.String,com.badlogic.gdx.utils.JsonValue) -> a
    void startObject(java.lang.String) -> b
    void startArray(java.lang.String) -> c
    void pop() -> a
    void string(java.lang.String,java.lang.String) -> a
    void number(java.lang.String,double) -> a
    void number(java.lang.String,long) -> a
    void bool(java.lang.String,boolean) -> a
    java.lang.String unescape(java.lang.String) -> d
com.badlogic.gdx.utils.JsonValue -> com.badlogic.gdx.utils.u:
    com.badlogic.gdx.utils.JsonValue$ValueType type -> f
    java.lang.String stringValue -> g
    double doubleValue -> h
    long longValue -> i
    java.lang.String name -> a
    com.badlogic.gdx.utils.JsonValue child -> b
    com.badlogic.gdx.utils.JsonValue next -> c
    com.badlogic.gdx.utils.JsonValue prev -> d
    int size -> e
    com.badlogic.gdx.utils.JsonValue get(int) -> a
    com.badlogic.gdx.utils.JsonValue get(java.lang.String) -> a
    com.badlogic.gdx.utils.JsonValue require(java.lang.String) -> b
    com.badlogic.gdx.utils.JsonValue remove(java.lang.String) -> c
    java.lang.String asString() -> a
    float asFloat() -> b
    double asDouble() -> c
    long asLong() -> d
    int asInt() -> e
    boolean asBoolean() -> f
    byte asByte() -> g
    short asShort() -> h
    float[] asFloatArray() -> i
    short[] asShortArray() -> j
    java.lang.String getString(java.lang.String,java.lang.String) -> a
    float getFloat(java.lang.String,float) -> a
    java.lang.String getString(java.lang.String) -> d
    float getFloat(java.lang.String) -> e
    float getFloat(int) -> b
    short getShort(int) -> c
    boolean isArray() -> k
    boolean isObject() -> l
    boolean isString() -> m
    boolean isNumber() -> n
    boolean isDouble() -> o
    boolean isLong() -> p
    boolean isBoolean() -> q
    boolean isNull() -> r
    boolean isValue() -> s
    java.lang.String name() -> t
    void setName(java.lang.String) -> f
    com.badlogic.gdx.utils.JsonValue child() -> u
    com.badlogic.gdx.utils.JsonValue next() -> v
    void set(java.lang.String) -> g
    void set(double) -> a
    void set(long) -> a
    void set(boolean) -> a
    java.lang.String toString() -> toString
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,int) -> a
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> a
    void prettyPrint(com.badlogic.gdx.utils.JsonValue,com.badlogic.gdx.utils.StringBuilder,int,com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> a
    boolean isFlat(com.badlogic.gdx.utils.JsonValue) -> a
    boolean isNumeric(com.badlogic.gdx.utils.JsonValue) -> b
    void indent(int,com.badlogic.gdx.utils.StringBuilder) -> a
    com.badlogic.gdx.utils.JsonValue$JsonIterator iterator() -> w
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.JsonValue$1 -> com.badlogic.gdx.utils.v:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonValue$ValueType -> a
com.badlogic.gdx.utils.JsonValue$JsonIterator -> com.badlogic.gdx.utils.w:
    com.badlogic.gdx.utils.JsonValue entry -> a
    com.badlogic.gdx.utils.JsonValue current -> b
    com.badlogic.gdx.utils.JsonValue this$0 -> c
    boolean hasNext() -> hasNext
    com.badlogic.gdx.utils.JsonValue next() -> a
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings -> com.badlogic.gdx.utils.x:
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> a
    int singleLineColumns -> b
    boolean wrapNumericArrays -> c
com.badlogic.gdx.utils.JsonValue$ValueType -> com.badlogic.gdx.utils.y:
    com.badlogic.gdx.utils.JsonValue$ValueType object -> a
    com.badlogic.gdx.utils.JsonValue$ValueType array -> b
    com.badlogic.gdx.utils.JsonValue$ValueType stringValue -> c
    com.badlogic.gdx.utils.JsonValue$ValueType doubleValue -> d
    com.badlogic.gdx.utils.JsonValue$ValueType longValue -> e
    com.badlogic.gdx.utils.JsonValue$ValueType booleanValue -> f
    com.badlogic.gdx.utils.JsonValue$ValueType nullValue -> g
    com.badlogic.gdx.utils.JsonValue$ValueType[] $VALUES -> h
    com.badlogic.gdx.utils.JsonValue$ValueType[] values() -> values
    com.badlogic.gdx.utils.JsonValue$ValueType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.utils.JsonWriter -> com.badlogic.gdx.utils.z:
    java.io.Writer writer -> a
    com.badlogic.gdx.utils.Array stack -> b
    com.badlogic.gdx.utils.JsonWriter$JsonObject current -> c
    boolean named -> d
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> e
    void setOutputType(com.badlogic.gdx.utils.JsonWriter$OutputType) -> a
    com.badlogic.gdx.utils.JsonWriter name(java.lang.String) -> a
    com.badlogic.gdx.utils.JsonWriter object() -> a
    com.badlogic.gdx.utils.JsonWriter array() -> b
    com.badlogic.gdx.utils.JsonWriter value(java.lang.Object) -> a
    com.badlogic.gdx.utils.JsonWriter set(java.lang.String,java.lang.Object) -> a
    com.badlogic.gdx.utils.JsonWriter pop() -> c
    void write(char[],int,int) -> write
    void flush() -> flush
    void close() -> close
com.badlogic.gdx.utils.JsonWriter$1 -> com.badlogic.gdx.utils.aa:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonWriter$OutputType -> a
com.badlogic.gdx.utils.JsonWriter$JsonObject -> com.badlogic.gdx.utils.ab:
    boolean array -> a
    boolean needsComma -> b
    com.badlogic.gdx.utils.JsonWriter this$0 -> c
    void close() -> a
com.badlogic.gdx.utils.JsonWriter$OutputType -> com.badlogic.gdx.utils.ac:
    com.badlogic.gdx.utils.JsonWriter$OutputType json -> a
    com.badlogic.gdx.utils.JsonWriter$OutputType javascript -> b
    com.badlogic.gdx.utils.JsonWriter$OutputType minimal -> c
    java.util.regex.Pattern javascriptPattern -> d
    java.util.regex.Pattern minimalNamePattern -> e
    java.util.regex.Pattern minimalValuePattern -> f
    com.badlogic.gdx.utils.JsonWriter$OutputType[] $VALUES -> g
    com.badlogic.gdx.utils.JsonWriter$OutputType[] values() -> values
    com.badlogic.gdx.utils.JsonWriter$OutputType valueOf(java.lang.String) -> valueOf
    java.lang.String quoteValue(java.lang.Object) -> a
    java.lang.String quoteName(java.lang.String) -> a
com.badlogic.gdx.utils.Logger -> com.badlogic.gdx.utils.ad:
    java.lang.String tag -> a
    int level -> b
    void debug(java.lang.String) -> a
    void info(java.lang.String) -> b
    void error(java.lang.String,java.lang.Throwable) -> a
    int getLevel() -> a
com.badlogic.gdx.utils.LongMap -> com.badlogic.gdx.utils.ae:
    int size -> a
    long[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    java.lang.Object zeroValue -> f
    boolean hasZeroValue -> g
    float loadFactor -> h
    int hashShift -> i
    int mask -> j
    int threshold -> k
    int stashCapacity -> l
    int pushIterations -> m
    com.badlogic.gdx.utils.LongMap$Entries entries1 -> n
    com.badlogic.gdx.utils.LongMap$Entries entries2 -> o
    java.lang.Object put(long,java.lang.Object) -> a
    void putResize(long,java.lang.Object) -> b
    void push(long,java.lang.Object,int,long,int,long,int,long) -> a
    void putStash(long,java.lang.Object) -> c
    java.lang.Object get(long) -> a
    java.lang.Object getStash(long,java.lang.Object) -> d
    void removeStashIndex(int) -> a
    void resize(int) -> b
    int hash2(long) -> b
    int hash3(long) -> c
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.LongMap$Entries entries() -> a
com.badlogic.gdx.utils.LongMap$Entries -> com.badlogic.gdx.utils.af:
    com.badlogic.gdx.utils.LongMap$Entry entry -> f
    com.badlogic.gdx.utils.LongMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.LongMap$Entry -> com.badlogic.gdx.utils.ag:
    long key -> a
    java.lang.Object value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.LongMap$MapIterator -> com.badlogic.gdx.utils.ah:
    boolean hasNext -> a
    com.badlogic.gdx.utils.LongMap map -> b
    int nextIndex -> c
    int currentIndex -> d
    boolean valid -> e
    void reset() -> b
    void findNextIndex() -> c
    void remove() -> remove
com.badlogic.gdx.utils.NumberUtils -> com.badlogic.gdx.utils.ai:
    boolean intToFloatColorMask -> a
    int floatToIntBits(float) -> a
    int floatToRawIntBits(float) -> b
    int floatToIntColor(float) -> c
    float intToFloatColor(int) -> a
com.badlogic.gdx.utils.ObjectIntMap -> com.badlogic.gdx.utils.aj:
    int size -> a
    java.lang.Object[] keyTable -> b
    int[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    float loadFactor -> f
    int hashShift -> g
    int mask -> h
    int threshold -> i
    int stashCapacity -> j
    int pushIterations -> k
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries1 -> l
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries2 -> m
    void put(java.lang.Object,int) -> a
    void putResize(java.lang.Object,int) -> c
    void push(java.lang.Object,int,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void putStash(java.lang.Object,int) -> d
    int get(java.lang.Object,int) -> b
    int getStash(java.lang.Object,int) -> e
    void removeStashIndex(int) -> a
    void clear() -> a
    void resize(int) -> b
    int hash2(int) -> c
    int hash3(int) -> d
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries() -> b
com.badlogic.gdx.utils.ObjectIntMap$Entries -> com.badlogic.gdx.utils.ak:
    com.badlogic.gdx.utils.ObjectIntMap$Entry entry -> f
    com.badlogic.gdx.utils.ObjectIntMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.ObjectIntMap$Entry -> com.badlogic.gdx.utils.al:
    java.lang.Object key -> a
    int value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.ObjectIntMap$MapIterator -> com.badlogic.gdx.utils.am:
    boolean hasNext -> a
    com.badlogic.gdx.utils.ObjectIntMap map -> b
    int nextIndex -> c
    int currentIndex -> d
    boolean valid -> e
    void reset() -> b
    void findNextIndex() -> c
    void remove() -> remove
com.badlogic.gdx.utils.ObjectMap -> com.badlogic.gdx.utils.an:
    int size -> a
    java.lang.Object[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    float loadFactor -> f
    int hashShift -> g
    int mask -> h
    int threshold -> i
    int stashCapacity -> j
    int pushIterations -> k
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> l
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> m
    com.badlogic.gdx.utils.ObjectMap$Values values1 -> n
    com.badlogic.gdx.utils.ObjectMap$Values values2 -> o
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> p
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> q
    java.lang.Object put(java.lang.Object,java.lang.Object) -> a
    java.lang.Object put_internal(java.lang.Object,java.lang.Object) -> b
    void putResize(java.lang.Object,java.lang.Object) -> c
    void push(java.lang.Object,java.lang.Object,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void putStash(java.lang.Object,java.lang.Object) -> d
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object getStash(java.lang.Object) -> e
    java.lang.Object remove(java.lang.Object) -> b
    java.lang.Object removeStash(java.lang.Object) -> c
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean containsKey(java.lang.Object) -> d
    boolean containsKeyStash(java.lang.Object) -> f
    void resize(int) -> b
    int hash2(int) -> c
    int hash3(int) -> d
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String,boolean) -> a
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    com.badlogic.gdx.utils.ObjectMap$Values values() -> c
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> d
com.badlogic.gdx.utils.ObjectMap$Entries -> com.badlogic.gdx.utils.ao:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> a
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.ObjectMap$Entry -> com.badlogic.gdx.utils.ap:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.ObjectMap$Keys -> com.badlogic.gdx.utils.aq:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    com.badlogic.gdx.utils.Array toArray(com.badlogic.gdx.utils.Array) -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap$MapIterator -> com.badlogic.gdx.utils.ar:
    boolean hasNext -> b
    com.badlogic.gdx.utils.ObjectMap map -> c
    int nextIndex -> d
    int currentIndex -> e
    boolean valid -> f
    void reset() -> b
    void findNextIndex() -> c
    void remove() -> remove
com.badlogic.gdx.utils.ObjectMap$Values -> com.badlogic.gdx.utils.as:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.ObjectSet -> com.badlogic.gdx.utils.at:
    int size -> a
    java.lang.Object[] keyTable -> b
    int capacity -> c
    int stashSize -> d
    float loadFactor -> e
    int hashShift -> f
    int mask -> g
    int threshold -> h
    int stashCapacity -> i
    int pushIterations -> j
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator1 -> k
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator2 -> l
    boolean add(java.lang.Object) -> a
    void addResize(java.lang.Object) -> c
    void push(java.lang.Object,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void addStash(java.lang.Object) -> d
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean contains(java.lang.Object) -> b
    boolean containsKeyStash(java.lang.Object) -> e
    void resize(int) -> b
    int hash2(int) -> c
    int hash3(int) -> d
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> b
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator -> com.badlogic.gdx.utils.au:
    boolean hasNext -> a
    com.badlogic.gdx.utils.ObjectSet set -> b
    int nextIndex -> c
    int currentIndex -> d
    boolean valid -> e
    void reset() -> a
    void findNextIndex() -> b
    void remove() -> remove
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.OrderedMap -> com.badlogic.gdx.utils.av:
    com.badlogic.gdx.utils.Array keys -> f
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> g
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> h
    com.badlogic.gdx.utils.ObjectMap$Values values1 -> i
    com.badlogic.gdx.utils.ObjectMap$Values values2 -> j
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> k
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> l
    java.lang.Object put(java.lang.Object,java.lang.Object) -> a
    java.lang.Object remove(java.lang.Object) -> b
    void clear() -> a
    com.badlogic.gdx.utils.Array orderedKeys() -> e
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    com.badlogic.gdx.utils.ObjectMap$Values values() -> c
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> d
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries -> com.badlogic.gdx.utils.aw:
    com.badlogic.gdx.utils.Array keys -> g
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys -> com.badlogic.gdx.utils.ax:
    com.badlogic.gdx.utils.Array keys -> a
    void reset() -> b
    java.lang.Object next() -> next
    void remove() -> remove
com.badlogic.gdx.utils.OrderedMap$OrderedMapValues -> com.badlogic.gdx.utils.ay:
    com.badlogic.gdx.utils.Array keys -> a
    void reset() -> b
    java.lang.Object next() -> next
    void remove() -> remove
com.badlogic.gdx.utils.Pool -> com.badlogic.gdx.utils.az:
    int max -> b
    int peak -> c
    com.badlogic.gdx.utils.Array freeObjects -> a
    java.lang.Object newObject() -> b
    java.lang.Object obtain() -> c
    void free(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array) -> a
com.badlogic.gdx.utils.Pool$Poolable -> com.badlogic.gdx.utils.ba:
    void reset() -> b
com.badlogic.gdx.utils.Pools -> com.badlogic.gdx.utils.bb:
    com.badlogic.gdx.utils.ObjectMap typePools -> a
    com.badlogic.gdx.utils.Pool get(java.lang.Class,int) -> a
    com.badlogic.gdx.utils.Pool get(java.lang.Class) -> a
    java.lang.Object obtain(java.lang.Class) -> b
    void free(java.lang.Object) -> a
com.badlogic.gdx.utils.PropertiesUtils -> com.badlogic.gdx.utils.bc:
    void load(com.badlogic.gdx.utils.ObjectMap,java.io.Reader) -> a
com.badlogic.gdx.utils.ReflectionPool -> com.badlogic.gdx.utils.bd:
    com.badlogic.gdx.utils.reflect.Constructor constructor -> a
    com.badlogic.gdx.utils.reflect.Constructor findConstructor(java.lang.Class) -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.utils.Scaling -> com.badlogic.gdx.utils.be:
    com.badlogic.gdx.utils.Scaling fit -> a
    com.badlogic.gdx.utils.Scaling fill -> b
    com.badlogic.gdx.utils.Scaling fillX -> c
    com.badlogic.gdx.utils.Scaling fillY -> d
    com.badlogic.gdx.utils.Scaling stretch -> e
    com.badlogic.gdx.utils.Scaling stretchX -> f
    com.badlogic.gdx.utils.Scaling stretchY -> g
    com.badlogic.gdx.utils.Scaling none -> h
    com.badlogic.gdx.math.Vector2 temp -> i
    com.badlogic.gdx.utils.Scaling[] $VALUES -> j
    com.badlogic.gdx.utils.Scaling[] values() -> values
    com.badlogic.gdx.utils.Scaling valueOf(java.lang.String) -> valueOf
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$1 -> com.badlogic.gdx.utils.bf:
    int[] $SwitchMap$com$badlogic$gdx$utils$Scaling -> a
com.badlogic.gdx.utils.SerializationException -> com.badlogic.gdx.utils.bg:
    java.lang.StringBuffer trace -> a
    java.lang.String getMessage() -> getMessage
    void addTrace(java.lang.String) -> a
com.badlogic.gdx.utils.SharedLibraryLoader -> com.badlogic.gdx.utils.bh:
    boolean isWindows -> a
    boolean isLinux -> b
    boolean isMac -> c
    boolean isIos -> d
    boolean isAndroid -> e
    boolean isARM -> f
    boolean is64Bit -> g
    java.lang.String abi -> h
    java.util.HashSet loadedLibraries -> i
    java.lang.String nativesJar -> j
    java.lang.String crc(java.io.InputStream) -> a
    java.lang.String mapLibraryName(java.lang.String) -> a
    void load(java.lang.String) -> b
    java.io.InputStream readFile(java.lang.String) -> c
    java.io.File extractFile(java.lang.String,java.lang.String,java.io.File) -> a
    void loadFile(java.lang.String) -> d
    java.lang.Throwable loadFile(java.lang.String,java.lang.String,java.io.File) -> b
com.badlogic.gdx.utils.ShortArray -> com.badlogic.gdx.utils.bi:
    short[] items -> a
    int size -> b
    boolean ordered -> c
    void add(short) -> a
    short removeIndex(int) -> a
    void clear() -> a
    short[] ensureCapacity(int) -> b
    short[] resize(int) -> c
    short[] toArray() -> b
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.SnapshotArray -> com.badlogic.gdx.utils.bj:
    java.lang.Object[] snapshot -> d
    java.lang.Object[] recycled -> e
    int snapshots -> f
    java.lang.Object[] begin() -> f
    void end() -> g
    void modified() -> h
    void set(int,java.lang.Object) -> a
    boolean removeValue(java.lang.Object,boolean) -> c
    java.lang.Object removeIndex(int) -> b
    java.lang.Object pop() -> a
    void clear() -> d
    void sort(java.util.Comparator) -> a
    void reverse() -> e
com.badlogic.gdx.utils.Sort -> com.badlogic.gdx.utils.bk:
    com.badlogic.gdx.utils.Sort instance -> a
    com.badlogic.gdx.utils.TimSort timSort -> b
    void sort(java.lang.Object[],java.util.Comparator,int,int) -> a
    com.badlogic.gdx.utils.Sort instance() -> a
com.badlogic.gdx.utils.StreamUtils -> com.badlogic.gdx.utils.bl:
    byte[] EMPTY_BYTES -> a
    void copyStream(java.io.InputStream,java.io.OutputStream) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream,int) -> a
    byte[] copyStreamToByteArray(java.io.InputStream,int) -> a
    void closeQuietly(java.io.Closeable) -> a
com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream -> com.badlogic.gdx.utils.bm:
    byte[] toByteArray() -> toByteArray
com.badlogic.gdx.utils.StringBuilder -> com.badlogic.gdx.utils.bn:
    char[] chars -> a
    int length -> b
    char[] digits -> c
    int numChars(int,int) -> a
    int numChars(long,int) -> a
    void enlargeBuffer(int) -> c
    void appendNull() -> a
    void append0(char[]) -> a
    void append0(char[],int,int) -> a
    void append0(char) -> a
    void append0(java.lang.String) -> a
    void append0(java.lang.CharSequence,int,int) -> a
    char charAt(int) -> charAt
    int length() -> length
    void setLength(int) -> a
    java.lang.String substring(int,int) -> b
    java.lang.String toString() -> toString
    java.lang.CharSequence subSequence(int,int) -> subSequence
    com.badlogic.gdx.utils.StringBuilder append(boolean) -> a
    com.badlogic.gdx.utils.StringBuilder append(char) -> b
    com.badlogic.gdx.utils.StringBuilder append(int) -> b
    com.badlogic.gdx.utils.StringBuilder append(int,int) -> c
    com.badlogic.gdx.utils.StringBuilder append(int,int,char) -> a
    com.badlogic.gdx.utils.StringBuilder append(long) -> a
    com.badlogic.gdx.utils.StringBuilder append(long,int) -> b
    com.badlogic.gdx.utils.StringBuilder append(long,int,char) -> a
    com.badlogic.gdx.utils.StringBuilder append(float) -> a
    com.badlogic.gdx.utils.StringBuilder append(double) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.Object) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.String) -> b
    com.badlogic.gdx.utils.StringBuilder append(char[]) -> b
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence) -> a
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence,int,int) -> b
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder,int,int) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
com.badlogic.gdx.utils.TextFormatter -> com.badlogic.gdx.utils.bo:
    java.text.MessageFormat messageFormat -> a
    com.badlogic.gdx.utils.StringBuilder buffer -> b
com.badlogic.gdx.utils.TimSort -> com.badlogic.gdx.utils.bp:
    java.lang.Object[] a -> a
    java.util.Comparator c -> b
    int minGallop -> c
    java.lang.Object[] tmp -> d
    int tmpCount -> e
    int stackSize -> f
    int[] runBase -> g
    int[] runLen -> h
    void doSort(java.lang.Object[],java.util.Comparator,int,int) -> a
    void binarySort(java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int,java.util.Comparator) -> a
    void reverseRange(java.lang.Object[],int,int) -> a
    int minRunLength(int) -> a
    void pushRun(int,int) -> a
    void mergeCollapse() -> a
    void mergeForceCollapse() -> b
    void mergeAt(int) -> b
    int gallopLeft(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int gallopRight(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> b
    void mergeLo(int,int,int,int) -> a
    void mergeHi(int,int,int,int) -> b
    java.lang.Object[] ensureCapacity(int) -> c
    void rangeCheck(int,int,int) -> a
com.badlogic.gdx.utils.TimeUtils -> com.badlogic.gdx.utils.bq:
    long nanoTime() -> a
com.badlogic.gdx.utils.Timer -> com.badlogic.gdx.utils.br:
    com.badlogic.gdx.utils.Array instances -> a
    com.badlogic.gdx.utils.Timer$TimerThread thread -> b
    com.badlogic.gdx.utils.Timer instance -> c
    com.badlogic.gdx.utils.Array tasks -> d
    com.badlogic.gdx.utils.Timer instance() -> a
    void scheduleTask(com.badlogic.gdx.utils.Timer$Task,float) -> a
    void scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float,int) -> a
    void start() -> b
    long update(long,long) -> a
    void delay(long) -> a
    void wake() -> c
    void schedule(com.badlogic.gdx.utils.Timer$Task,float) -> b
    void checkStatics() -> d
com.badlogic.gdx.utils.Timer$Task -> com.badlogic.gdx.utils.bs:
    long executeTimeMillis -> b
    long intervalMillis -> c
    int repeatCount -> d
    void cancel() -> a
    boolean isScheduled() -> b
com.badlogic.gdx.utils.Timer$TimerThread -> com.badlogic.gdx.utils.bt:
    com.badlogic.gdx.Application app -> a
    long pauseMillis -> b
    void run() -> run
    void resume() -> b
    void pause() -> a
    void dispose() -> c
com.badlogic.gdx.utils.UBJsonReader -> com.badlogic.gdx.utils.bu:
    boolean oldFormat -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.InputStream) -> a
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.DataInputStream) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.DataInputStream,byte) -> a
    com.badlogic.gdx.utils.JsonValue parseArray(java.io.DataInputStream) -> b
    com.badlogic.gdx.utils.JsonValue parseObject(java.io.DataInputStream) -> c
    com.badlogic.gdx.utils.JsonValue parseData(java.io.DataInputStream,byte) -> b
    java.lang.String parseString(java.io.DataInputStream,byte) -> c
    java.lang.String parseString(java.io.DataInputStream,boolean,byte) -> a
    long parseSize(java.io.DataInputStream,boolean,long) -> a
    long parseSize(java.io.DataInputStream,byte,boolean,long) -> a
    short readUChar(java.io.DataInputStream) -> d
    int readUShort(java.io.DataInputStream) -> e
    long readUInt(java.io.DataInputStream) -> f
    java.lang.String readString(java.io.DataInputStream,long) -> a
com.badlogic.gdx.utils.async.AsyncExecutor -> com.badlogic.gdx.utils.a.a:
    java.util.concurrent.ExecutorService executor -> a
    com.badlogic.gdx.utils.async.AsyncResult submit(com.badlogic.gdx.utils.async.AsyncTask) -> a
    void dispose() -> c
com.badlogic.gdx.utils.async.AsyncExecutor$1 -> com.badlogic.gdx.utils.a.b:
    com.badlogic.gdx.utils.async.AsyncExecutor this$0 -> a
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
com.badlogic.gdx.utils.async.AsyncExecutor$2 -> com.badlogic.gdx.utils.a.c:
    com.badlogic.gdx.utils.async.AsyncTask val$task -> a
    com.badlogic.gdx.utils.async.AsyncExecutor this$0 -> b
    java.lang.Object call() -> call
com.badlogic.gdx.utils.async.AsyncResult -> com.badlogic.gdx.utils.a.d:
    java.util.concurrent.Future future -> a
    boolean isDone() -> a
    java.lang.Object get() -> b
com.badlogic.gdx.utils.async.AsyncTask -> com.badlogic.gdx.utils.a.e:
    java.lang.Object call() -> d
com.badlogic.gdx.utils.async.ThreadUtils -> com.badlogic.gdx.utils.a.f:
    void yield() -> a
com.badlogic.gdx.utils.reflect.ArrayReflection -> com.badlogic.gdx.utils.b.a:
    java.lang.Object newInstance(java.lang.Class,int) -> a
    int getLength(java.lang.Object) -> a
    java.lang.Object get(java.lang.Object,int) -> a
    void set(java.lang.Object,int,java.lang.Object) -> a
com.badlogic.gdx.utils.reflect.ClassReflection -> com.badlogic.gdx.utils.b.b:
    java.lang.Class forName(java.lang.String) -> a
    java.lang.String getSimpleName(java.lang.Class) -> a
    boolean isAssignableFrom(java.lang.Class,java.lang.Class) -> a
    boolean isMemberClass(java.lang.Class) -> b
    boolean isStaticClass(java.lang.Class) -> c
    java.lang.Object newInstance(java.lang.Class) -> d
    com.badlogic.gdx.utils.reflect.Constructor getConstructor(java.lang.Class,java.lang.Class[]) -> a
    com.badlogic.gdx.utils.reflect.Constructor getDeclaredConstructor(java.lang.Class,java.lang.Class[]) -> b
    com.badlogic.gdx.utils.reflect.Field[] getDeclaredFields(java.lang.Class) -> e
com.badlogic.gdx.utils.reflect.Constructor -> com.badlogic.gdx.utils.b.c:
    java.lang.reflect.Constructor constructor -> a
    java.lang.Class getDeclaringClass() -> a
    void setAccessible(boolean) -> a
    java.lang.Object newInstance(java.lang.Object[]) -> a
com.badlogic.gdx.utils.reflect.Field -> com.badlogic.gdx.utils.b.d:
    java.lang.reflect.Field field -> a
    java.lang.String getName() -> a
    java.lang.Class getType() -> b
    java.lang.Class getDeclaringClass() -> c
    boolean isAccessible() -> d
    void setAccessible(boolean) -> a
    boolean isStatic() -> e
    boolean isTransient() -> f
    boolean isSynthetic() -> g
    java.lang.Class getElementType(int) -> a
    java.lang.Object get(java.lang.Object) -> a
    void set(java.lang.Object,java.lang.Object) -> a
com.badlogic.gdx.utils.reflect.ReflectionException -> com.badlogic.gdx.utils.b.e:
com.badlogic.gdx.utils.viewport.ExtendViewport -> com.badlogic.gdx.utils.c.a:
    float minWorldWidth -> a
    float minWorldHeight -> b
    float maxWorldWidth -> c
    float maxWorldHeight -> d
    void update(int,int,boolean) -> a
com.badlogic.gdx.utils.viewport.ScalingViewport -> com.badlogic.gdx.utils.c.b:
    com.badlogic.gdx.utils.Scaling scaling -> a
    void update(int,int,boolean) -> a
com.badlogic.gdx.utils.viewport.Viewport -> com.badlogic.gdx.utils.c.c:
    com.badlogic.gdx.graphics.Camera camera -> a
    float worldWidth -> b
    float worldHeight -> c
    int screenX -> d
    int screenY -> e
    int screenWidth -> f
    int screenHeight -> g
    com.badlogic.gdx.math.Vector3 tmp -> h
    void apply(boolean) -> a
    void update(int,int,boolean) -> a
    com.badlogic.gdx.math.Vector2 unproject(com.badlogic.gdx.math.Vector2) -> a
    void calculateScissors(com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.graphics.Camera getCamera() -> a
    void setCamera(com.badlogic.gdx.graphics.Camera) -> a
    float getWorldWidth() -> b
    float getWorldHeight() -> c
    void setWorldSize(float,float) -> a
    int getScreenX() -> d
    int getScreenY() -> e
    int getScreenWidth() -> f
    int getScreenHeight() -> g
    void setScreenBounds(int,int,int,int) -> a
com.nha.pelsdreams.PelsDreamsGame -> com.nha.pelsdreams.a:
    void create() -> a
com.nha.pelsdreams.android.AndroidLauncher -> com.nha.pelsdreams.android.AndroidLauncher:
    void onCreate(android.os.Bundle) -> onCreate
com.nha.pelsdreams.assets.AssetEffects -> com.nha.pelsdreams.a.a:
    com.badlogic.gdx.graphics.g2d.Animation smokeLaunch -> a
com.nha.pelsdreams.assets.AssetEnemyWorld001 -> com.nha.pelsdreams.a.b:
    com.badlogic.gdx.graphics.g2d.Animation snake_first -> a
    com.badlogic.gdx.graphics.g2d.Animation snake_second -> b
    com.badlogic.gdx.graphics.g2d.Animation arrows -> c
    com.badlogic.gdx.graphics.g2d.Animation worm -> d
com.nha.pelsdreams.assets.AssetFonts -> com.nha.pelsdreams.a.c:
    com.badlogic.gdx.graphics.g2d.BitmapFont generalNormal -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont generalNormalFlipped -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont generalBig -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont generalBigFlipped -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont yellowNormalFlipped -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont yellowBig -> f
    com.badlogic.gdx.graphics.g2d.BitmapFont yellowBigFlipped -> g
com.nha.pelsdreams.assets.AssetGoal -> com.nha.pelsdreams.a.d:
    com.badlogic.gdx.graphics.g2d.TextureRegion goal -> a
    com.badlogic.gdx.graphics.g2d.ParticleEffect particleEffect -> b
com.nha.pelsdreams.assets.AssetInGameUI -> com.nha.pelsdreams.a.e:
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle menuButtonStyle -> a
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle upControlButtonStyle -> b
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle downControlButtonStyle -> c
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> d
com.nha.pelsdreams.assets.AssetItem -> com.nha.pelsdreams.a.f:
    com.badlogic.gdx.graphics.g2d.Animation animation -> a
com.nha.pelsdreams.assets.AssetMainItem -> com.nha.pelsdreams.a.g:
    com.badlogic.gdx.graphics.g2d.Animation animation -> a
    com.badlogic.gdx.graphics.g2d.Animation animationIdle -> b
com.nha.pelsdreams.assets.AssetPowersUp -> com.nha.pelsdreams.a.h:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion powerUpRed -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion powerUpBlue -> b
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion powerUpGreen -> c
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion powerUpRedGUI -> d
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion powerUpBlueGUI -> e
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion powerUpGreenGUI -> f
com.nha.pelsdreams.assets.AssetRunner -> com.nha.pelsdreams.a.i:
    com.badlogic.gdx.graphics.g2d.Animation anim_run -> a
    com.badlogic.gdx.graphics.g2d.Animation anim_jump -> b
    com.badlogic.gdx.graphics.g2d.Animation anim_jump_rising -> c
    com.badlogic.gdx.graphics.g2d.Animation anim_jump_falling -> d
    com.badlogic.gdx.graphics.g2d.Animation anim_dodging -> e
    com.badlogic.gdx.graphics.g2d.Animation anim_dodgingReversed -> f
    com.badlogic.gdx.graphics.g2d.Animation anim_dodged -> g
    com.badlogic.gdx.graphics.g2d.Animation anim_dead_rock -> h
    com.badlogic.gdx.graphics.g2d.Animation anim_dead_enemy -> i
    com.badlogic.gdx.graphics.g2d.Animation anim_dead_enemy_end -> j
    com.badlogic.gdx.graphics.g2d.ParticleEffect dustParticles -> k
    com.badlogic.gdx.graphics.g2d.ParticleEffect fallParticles -> l
com.nha.pelsdreams.assets.AssetWorld -> com.nha.pelsdreams.a.j:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion blueMountains -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion sun -> b
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion ground -> c
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion cloud1 -> d
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion cloud2 -> e
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion cloud3 -> f
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion background_layer2_1 -> g
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion background_layer2_2 -> h
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion background_layer2_2v1 -> i
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion background_layer2_2v2 -> j
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion background_layer2_2v4 -> k
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion platform -> l
com.nha.pelsdreams.enums.LevelObjectType -> com.nha.pelsdreams.b.a:
    com.nha.pelsdreams.enums.LevelObjectType EMPTY -> a
    com.nha.pelsdreams.enums.LevelObjectType PLATFORM -> b
    com.nha.pelsdreams.enums.LevelObjectType ENEMY_HORIZONTAL -> c
    com.nha.pelsdreams.enums.LevelObjectType ENEMY_JUMPER -> d
    com.nha.pelsdreams.enums.LevelObjectType ENEMY_STATIC -> e
    com.nha.pelsdreams.enums.LevelObjectType PLAYER_SPAWNPOINT -> f
    com.nha.pelsdreams.enums.LevelObjectType ITEM_POWER -> g
    com.nha.pelsdreams.enums.LevelObjectType ITEM -> h
    com.nha.pelsdreams.enums.LevelObjectType MAIN_ITEM -> i
    com.nha.pelsdreams.enums.LevelObjectType GOAL -> j
    com.nha.pelsdreams.enums.LevelObjectType[] ENUM$VALUES -> k
    com.nha.pelsdreams.enums.LevelObjectType[] values() -> values
    com.nha.pelsdreams.enums.LevelObjectType valueOf(java.lang.String) -> valueOf
com.nha.pelsdreams.enums.ShowButtonsType -> com.nha.pelsdreams.b.b:
    com.nha.pelsdreams.enums.ShowButtonsType ALL -> a
    com.nha.pelsdreams.enums.ShowButtonsType MENU_AND_RESTART -> b
    com.nha.pelsdreams.enums.ShowButtonsType CONTINUE -> c
    com.nha.pelsdreams.enums.ShowButtonsType[] ENUM$VALUES -> d
    com.nha.pelsdreams.enums.ShowButtonsType[] values() -> values
    com.nha.pelsdreams.enums.ShowButtonsType valueOf(java.lang.String) -> valueOf
com.nha.pelsdreams.enums.StateType -> com.nha.pelsdreams.b.c:
    com.nha.pelsdreams.enums.StateType GROUNDED -> a
    com.nha.pelsdreams.enums.StateType JUMP_RISING -> b
    com.nha.pelsdreams.enums.StateType JUMP_FALLING -> c
    com.nha.pelsdreams.enums.StateType DODGED -> d
    com.nha.pelsdreams.enums.StateType[] ENUM$VALUES -> e
    com.nha.pelsdreams.enums.StateType[] values() -> values
    com.nha.pelsdreams.enums.StateType valueOf(java.lang.String) -> valueOf
com.nha.pelsdreams.enums.UserDataType -> com.nha.pelsdreams.b.d:
    com.nha.pelsdreams.enums.UserDataType GROUND -> a
    com.nha.pelsdreams.enums.UserDataType PLATFORM -> b
    com.nha.pelsdreams.enums.UserDataType RUNNER -> c
    com.nha.pelsdreams.enums.UserDataType ENEMY_STATIC -> d
    com.nha.pelsdreams.enums.UserDataType ENEMY_HORIZONTAL -> e
    com.nha.pelsdreams.enums.UserDataType ENEMY_JUMPER -> f
    com.nha.pelsdreams.enums.UserDataType ITEM -> g
    com.nha.pelsdreams.enums.UserDataType MAIN_ITEM -> h
    com.nha.pelsdreams.enums.UserDataType POWER_UP -> i
    com.nha.pelsdreams.enums.UserDataType GOAL -> j
    com.nha.pelsdreams.enums.UserDataType[] ENUM$VALUES -> k
    com.nha.pelsdreams.enums.UserDataType[] values() -> values
    com.nha.pelsdreams.enums.UserDataType valueOf(java.lang.String) -> valueOf
com.nha.pelsdreams.game.AssetsLoading -> com.nha.pelsdreams.c.a:
    java.lang.String TAG -> a
    com.nha.pelsdreams.game.AssetsLoading instance -> b
    com.badlogic.gdx.assets.AssetManager assetManager -> e
    com.badlogic.gdx.graphics.g2d.TextureRegion loadingRegion -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion ballRegion -> d
    void load(com.badlogic.gdx.assets.AssetManager) -> a
    void dispose() -> c
    void error(com.badlogic.gdx.assets.AssetDescriptor,java.lang.Throwable) -> a
com.nha.pelsdreams.game.AssetsUI -> com.nha.pelsdreams.c.b:
    java.lang.String TAG -> a
    com.nha.pelsdreams.game.AssetsUI instance -> b
    com.badlogic.gdx.assets.AssetManager assetManager -> e
    com.badlogic.gdx.scenes.scene2d.ui.Skin skinMainMenu -> c
    com.badlogic.gdx.scenes.scene2d.ui.Skin skinWorldLevels -> d
    com.badlogic.gdx.assets.AssetManager getAssetManaget() -> a
    void load(com.badlogic.gdx.assets.AssetManager) -> a
    void getLoaded() -> b
    void dispose() -> c
    void error(com.badlogic.gdx.assets.AssetDescriptor,java.lang.Throwable) -> a
com.nha.pelsdreams.game.AssetsWorlds -> com.nha.pelsdreams.c.c:
    java.lang.String TAG -> a
    com.nha.pelsdreams.game.AssetsWorlds instance -> b
    com.badlogic.gdx.assets.AssetManager assetManager -> n
    com.nha.pelsdreams.assets.AssetFonts fonts -> c
    com.nha.pelsdreams.assets.AssetRunner runner -> d
    com.nha.pelsdreams.assets.AssetEnemyWorld001 enemiesWorld001 -> e
    com.nha.pelsdreams.assets.AssetMainItem mainItem -> f
    com.nha.pelsdreams.assets.AssetItem item -> g
    com.nha.pelsdreams.assets.AssetGoal goal -> h
    com.nha.pelsdreams.assets.AssetPowersUp powerUp -> i
    com.nha.pelsdreams.assets.AssetWorld world -> j
    com.nha.pelsdreams.assets.AssetEffects effects -> k
    com.nha.pelsdreams.assets.AssetInGameUI inGameUI -> l
    int worldnumber -> m
    com.badlogic.gdx.assets.AssetManager getAssetManaget() -> a
    void load(com.badlogic.gdx.assets.AssetManager,int) -> a
    void getLoaded() -> b
    void dispose() -> c
    void error(com.badlogic.gdx.assets.AssetDescriptor,java.lang.Throwable) -> a
com.nha.pelsdreams.game.LevelCreator -> com.nha.pelsdreams.c.d:
    java.lang.String TAG -> a
    com.nha.pelsdreams.game.objects.levels.Level level -> p
    int mainItemsObjetive -> b
    int itemsObjetive -> c
    com.nha.pelsdreams.game.objects.Runner runner -> d
    com.badlogic.gdx.utils.Array enemiesJumpers -> e
    com.badlogic.gdx.utils.Array enemiesHorizontals -> f
    com.badlogic.gdx.utils.Array enemiesStatics -> g
    com.badlogic.gdx.utils.Array platforms -> h
    com.badlogic.gdx.utils.Array mainItems -> i
    com.badlogic.gdx.utils.Array items -> j
    com.badlogic.gdx.utils.Array powerups -> k
    com.nha.pelsdreams.game.objects.Goal goal -> l
    com.nha.pelsdreams.game.objects.GoalParticles goalParticles -> m
    com.nha.pelsdreams.game.objects.Background background -> n
    com.nha.pelsdreams.game.objects.Ground ground -> o
    java.lang.String filename -> q
    int levelNumber -> r
    void init() -> c
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void update(float) -> a
    com.nha.pelsdreams.game.objects.levels.Level getLevel() -> a
    void dispose() -> b
com.nha.pelsdreams.game.WorldController -> com.nha.pelsdreams.c.e:
    java.lang.String TAG -> j
    com.nha.pelsdreams.screens.DirectedGame game -> k
    com.nha.pelsdreams.utils.SaveGameHelper$GameState gameState -> l
    com.badlogic.gdx.math.Rectangle screenLeftSide -> m
    com.badlogic.gdx.math.Rectangle screenRightSide -> n
    boolean isGameOver -> a
    boolean isLevelCompleted -> b
    boolean isLevelNotCompleted -> c
    com.badlogic.gdx.physics.box2d.World b2world -> d
    com.nha.pelsdreams.utils.CameraHelper cameraHelper -> e
    com.nha.pelsdreams.game.LevelCreator level -> f
    int lives -> g
    int mainItems -> h
    int items -> i
    float accum -> o
    float step -> p
    float maxAccum -> q
    void initLevel(com.nha.pelsdreams.game.LevelCreator) -> a
    void setGameOver() -> a
    void initPhysics() -> b
    void setupTouchControlAreas() -> d
    void update(float) -> a
    void handleDebugInput(float) -> b
    void handleInputGame(float) -> c
    boolean keyUp(int) -> b
    void beginContact(com.badlogic.gdx.physics.box2d.Contact) -> a
    void endContact(com.badlogic.gdx.physics.box2d.Contact) -> b
    void preSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.Manifold) -> a
    void postSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.ContactImpulse) -> a
    void dispose() -> c
com.nha.pelsdreams.game.WorldRenderer -> com.nha.pelsdreams.c.f:
    com.badlogic.gdx.graphics.OrthographicCamera camera -> a
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> b
    com.nha.pelsdreams.game.WorldController worldController -> c
    com.badlogic.gdx.physics.box2d.Box2DDebugRenderer b2debugRenderer -> d
    void init() -> a
    void render() -> b
    void resize(int,int) -> a
    void dispose() -> c
com.nha.pelsdreams.game.objects.AbstractGameObject -> com.nha.pelsdreams.c.a.a:
    com.badlogic.gdx.physics.box2d.Body body -> a
    com.nha.pelsdreams.enums.UserDataType userDataType -> b
    com.badlogic.gdx.math.Vector2 position -> c
    com.badlogic.gdx.math.Vector2 dimension -> d
    com.badlogic.gdx.math.Vector2 origin -> e
    com.badlogic.gdx.math.Vector2 scale -> f
    float rotation -> g
    com.badlogic.gdx.math.Rectangle bounds -> h
    float stateTime -> i
    float stateTimeEffect -> j
    com.badlogic.gdx.graphics.g2d.Animation animation -> k
    com.badlogic.gdx.graphics.g2d.Animation animationEffect -> l
    com.badlogic.gdx.math.Vector2 effectPosition -> m
    void update(float) -> a
    void setAnimation(com.badlogic.gdx.graphics.g2d.Animation) -> a
    void setAnimationEffect(com.badlogic.gdx.graphics.g2d.Animation) -> b
    void dispose() -> a
com.nha.pelsdreams.game.objects.Background -> com.nha.pelsdreams.c.a.b:
    com.badlogic.gdx.graphics.g2d.TextureRegion blueMountains -> n
    com.badlogic.gdx.graphics.g2d.TextureRegion sun -> o
    com.badlogic.gdx.graphics.g2d.TextureRegion cloud1 -> p
    com.badlogic.gdx.graphics.g2d.TextureRegion cloud2 -> q
    com.badlogic.gdx.graphics.g2d.TextureRegion cloud3 -> r
    com.badlogic.gdx.graphics.g2d.TextureRegion background_layer2_1 -> s
    com.badlogic.gdx.graphics.g2d.TextureRegion background_layer2_2 -> t
    com.badlogic.gdx.graphics.g2d.TextureRegion background_layer2_2v1 -> u
    com.badlogic.gdx.graphics.g2d.TextureRegion background_layer2_2v2 -> v
    com.badlogic.gdx.graphics.g2d.TextureRegion background_layer2_2v4 -> w
    void init() -> b
    void drawBackgroundMirror(com.badlogic.gdx.graphics.g2d.SpriteBatch,com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.SpriteBatch,com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float) -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void updateScrollPosition(com.badlogic.gdx.math.Vector2) -> a
com.nha.pelsdreams.game.objects.EnemyHorizontal -> com.nha.pelsdreams.c.a.c:
    java.lang.String TAG -> n
    com.badlogic.gdx.graphics.g2d.Animation arrows -> o
    com.badlogic.gdx.graphics.g2d.Animation animationSelected -> p
    com.badlogic.gdx.utils.Array enemies -> q
    com.badlogic.gdx.math.Vector2 velocity -> r
    boolean isLaunched -> s
    void init() -> b
    void update(float) -> a
    void setLaunch() -> c
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
com.nha.pelsdreams.game.objects.EnemyJumper -> com.nha.pelsdreams.c.a.d:
    java.lang.String TAG -> n
    float JUMP_TIME_MAX -> o
    com.badlogic.gdx.utils.Array worm -> p
    com.badlogic.gdx.utils.Array animationSelected -> q
    com.badlogic.gdx.utils.Array enemies -> r
    float DELAY_TIME -> s
    float delay -> t
    com.badlogic.gdx.math.Vector2 velocity -> u
    com.nha.pelsdreams.game.objects.EnemyJumper$JUMP_STATE jumpState -> v
    float timeJumping -> w
    int[] $SWITCH_TABLE$com$nha$pelsdreams$game$objects$EnemyJumper$JUMP_STATE -> x
    void init() -> b
    void update(float) -> a
    void updateMotionY(float) -> b
    void landed() -> c
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    int[] $SWITCH_TABLE$com$nha$pelsdreams$game$objects$EnemyJumper$JUMP_STATE() -> d
com.nha.pelsdreams.game.objects.EnemyJumper$JUMP_STATE -> com.nha.pelsdreams.c.a.e:
    com.nha.pelsdreams.game.objects.EnemyJumper$JUMP_STATE GROUNDED -> a
    com.nha.pelsdreams.game.objects.EnemyJumper$JUMP_STATE JUMP_RISING -> b
    com.nha.pelsdreams.game.objects.EnemyJumper$JUMP_STATE JUMP_FALLING -> c
    com.nha.pelsdreams.game.objects.EnemyJumper$JUMP_STATE[] ENUM$VALUES -> d
    com.nha.pelsdreams.game.objects.EnemyJumper$JUMP_STATE[] values() -> values
    com.nha.pelsdreams.game.objects.EnemyJumper$JUMP_STATE valueOf(java.lang.String) -> valueOf
com.nha.pelsdreams.game.objects.EnemyStatic -> com.nha.pelsdreams.c.a.f:
    java.lang.String TAG -> n
    com.badlogic.gdx.utils.Array snake -> o
    com.badlogic.gdx.utils.Array animationSelected -> p
    com.badlogic.gdx.utils.Array enemies -> q
    float DELAY_TIME -> r
    float delay -> s
    void init() -> b
    void update(float) -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
com.nha.pelsdreams.game.objects.Goal -> com.nha.pelsdreams.c.a.g:
    com.badlogic.gdx.graphics.g2d.TextureRegion goal -> p
    boolean isReached -> n
    boolean animFinished -> o
    float shakeTime -> q
    float shakeTimeLeft -> r
    float animUpDelay -> s
    void init() -> b
    void update(float) -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void reached() -> c
com.nha.pelsdreams.game.objects.GoalParticles -> com.nha.pelsdreams.c.a.h:
    com.badlogic.gdx.graphics.g2d.ParticleEffect particleEffect -> n
    com.badlogic.gdx.math.Vector2 position -> o
    float delay -> p
    void init() -> b
    void update(float) -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void start() -> c
    void stop(float) -> b
com.nha.pelsdreams.game.objects.Ground -> com.nha.pelsdreams.c.a.i:
    com.badlogic.gdx.graphics.g2d.TextureRegion ground -> n
    void init() -> b
    void drawBackground(com.badlogic.gdx.graphics.g2d.SpriteBatch,com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
com.nha.pelsdreams.game.objects.Item -> com.nha.pelsdreams.c.a.j:
    com.badlogic.gdx.graphics.g2d.Animation animItem -> p
    com.badlogic.gdx.graphics.g2d.ParticleEffect particleEffect -> n
    boolean collected -> o
    void init() -> c
    void update(float) -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void hit() -> b
    void dispose() -> a
com.nha.pelsdreams.game.objects.MainItem -> com.nha.pelsdreams.c.a.k:
    com.badlogic.gdx.graphics.g2d.Animation animation -> p
    com.badlogic.gdx.graphics.g2d.ParticleEffect particleEffect -> n
    boolean collected -> o
    float DELAY_TIME -> q
    float delay -> r
    void init() -> c
    void update(float) -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void hit() -> b
    void dispose() -> a
com.nha.pelsdreams.game.objects.Platform -> com.nha.pelsdreams.c.a.l:
    java.lang.String TAG -> n
    com.badlogic.gdx.graphics.g2d.TextureRegion regPlatform -> o
    int unitsAmount -> p
    void init() -> b
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
com.nha.pelsdreams.game.objects.PowerUp -> com.nha.pelsdreams.c.a.m:
    com.badlogic.gdx.graphics.g2d.TextureRegion regPowerUp -> o
    boolean collected -> n
    void init() -> b
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
com.nha.pelsdreams.game.objects.Runner -> com.nha.pelsdreams.c.a.n:
    java.lang.String TAG -> n
    float JUMP_TIME_MAX -> u
    float JUMP_TIME_MIN -> v
    float JUMP_TIME_OFFSET_FLYING -> w
    com.badlogic.gdx.graphics.g2d.Animation animRunning -> x
    com.badlogic.gdx.graphics.g2d.Animation animJump -> y
    com.badlogic.gdx.graphics.g2d.Animation animJumpRising -> z
    com.badlogic.gdx.graphics.g2d.Animation animJumpFalling -> A
    com.badlogic.gdx.graphics.g2d.Animation animDeadRock -> B
    com.badlogic.gdx.graphics.g2d.Animation animDeadEnemy -> C
    com.badlogic.gdx.graphics.g2d.Animation animDeadEnemyEnd -> D
    com.badlogic.gdx.graphics.g2d.Animation animDodgingReversed -> E
    com.badlogic.gdx.graphics.g2d.Animation animDodging -> F
    com.badlogic.gdx.graphics.g2d.Animation animDodged -> G
    com.badlogic.gdx.math.Vector2 velocity -> H
    com.badlogic.gdx.math.Vector2 originDodge -> I
    com.nha.pelsdreams.enums.StateType state -> o
    float timeJumping -> J
    boolean hasPowerup -> K
    float timeLeftPowerup -> p
    java.lang.Boolean isDeadRock -> q
    java.lang.Boolean isDeadEnemy -> r
    com.badlogic.gdx.graphics.g2d.ParticleEffect dustParticles -> s
    com.badlogic.gdx.graphics.g2d.ParticleEffect fallParticles -> t
    float deadEnemyTimeAnimation -> L
    int[] $SWITCH_TABLE$com$nha$pelsdreams$enums$StateType -> M
    void init() -> f
    void update(float) -> a
    void updateMotionY(float) -> b
    void setState(boolean,boolean) -> a
    void updateDeadState(float) -> c
    void deadByRock() -> b
    void deadByEnemy() -> c
    void landed() -> d
    void setGameOverEnemyAnimation(float) -> d
    void setPowerup(boolean) -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    int[] $SWITCH_TABLE$com$nha$pelsdreams$enums$StateType() -> e
com.nha.pelsdreams.game.objects.levels.Level -> com.nha.pelsdreams.c.a.a.a:
    com.badlogic.gdx.utils.Array levelObjects -> a
    int mainItemsObjective -> b
    int itemsObjective -> c
com.nha.pelsdreams.game.objects.levels.LevelObject -> com.nha.pelsdreams.c.a.a.b:
    com.badlogic.gdx.math.Vector2 position -> a
    com.nha.pelsdreams.enums.LevelObjectType type -> b
    int unitsAmount -> c
com.nha.pelsdreams.game.objects.levels.Levels -> com.nha.pelsdreams.c.a.a.c:
    com.badlogic.gdx.utils.Array levels -> a
com.nha.pelsdreams.screens.AbstractGameScreen -> com.nha.pelsdreams.d.a:
    com.nha.pelsdreams.screens.DirectedGame game -> a
    com.badlogic.gdx.scenes.scene2d.Stage stage -> b
    com.nha.pelsdreams.utils.SaveGameHelper$GameState gameState -> c
    boolean paused -> d
    com.nha.pelsdreams.utils.SaveGameHelper$GameState getGameState() -> a
    void setGameState(com.nha.pelsdreams.utils.SaveGameHelper$GameState) -> a
    boolean isPaused() -> b
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> c
    void hide() -> d
    void pause() -> e
    void initGame() -> f
    void resume() -> g
    com.badlogic.gdx.InputProcessor getInputProcessor() -> h
com.nha.pelsdreams.screens.DirectedGame -> com.nha.pelsdreams.d.b:
    boolean init -> b
    com.nha.pelsdreams.screens.AbstractGameScreen currScreen -> a
    com.nha.pelsdreams.screens.AbstractGameScreen nextScreen -> c
    com.badlogic.gdx.graphics.glutils.FrameBuffer currFbo -> d
    com.badlogic.gdx.graphics.glutils.FrameBuffer nextFbo -> e
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> f
    com.badlogic.gdx.utils.viewport.Viewport viewport -> g
    float trackElapsedTime -> h
    com.nha.pelsdreams.screens.transitions.ScreenTransition screenTransition -> i
    void setScreen(com.nha.pelsdreams.screens.AbstractGameScreen) -> a
    void setScreen(com.nha.pelsdreams.screens.AbstractGameScreen,com.nha.pelsdreams.screens.transitions.ScreenTransition) -> a
    com.nha.pelsdreams.screens.AbstractGameScreen getCurrScreen() -> f
    com.nha.pelsdreams.screens.AbstractGameScreen getNextScreen() -> g
    void create() -> a
    void resize(int,int) -> a
    void render() -> b
    void pause() -> c
    void resume() -> d
    void dispose() -> e
com.nha.pelsdreams.screens.GameScreen -> com.nha.pelsdreams.d.c:
    java.lang.String TAG -> f
    com.nha.pelsdreams.game.WorldController worldController -> g
    com.nha.pelsdreams.game.WorldRenderer worldRenderer -> h
    com.badlogic.gdx.InputMultiplexer multiplexer -> i
    com.nha.pelsdreams.screens.actors.PauseScreenActor pauseScreenActor -> j
    com.nha.pelsdreams.screens.actors.CompletedScreenActor completedScreenActor -> k
    com.nha.pelsdreams.screens.actors.NotCompletedScreenActor notCompletedScreenActor -> l
    com.nha.pelsdreams.screens.actors.InitScreenActor initScreenActor -> m
    com.nha.pelsdreams.screens.actors.GameOverScreenActor gameOverScreenActor -> n
    com.nha.pelsdreams.screens.actors.GameGuiActor gameGuiActor -> e
    float timeLeftGameOverDelay -> o
    float timeLeftGameFinishedDelay -> p
    boolean isShowingScreenActor -> q
    com.nha.pelsdreams.game.WorldController getWorldController() -> i
    void initGame() -> f
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> c
    void hide() -> d
    void pause() -> e
    void resume() -> g
    void levelCompleted() -> j
    void levelNotCompleted() -> k
    void gameOver() -> l
    void saveGameState(boolean) -> a
    void setInputProcessor(boolean) -> b
    com.badlogic.gdx.InputProcessor getInputProcessor() -> h
com.nha.pelsdreams.screens.LevelScreen -> com.nha.pelsdreams.d.d:
    java.lang.String TAG -> g
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> h
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener backClickListener -> e
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener levelClickListener -> f
    void rebuildStage() -> j
    com.badlogic.gdx.scenes.scene2d.ui.Table buildBackgroundTable() -> k
    com.badlogic.gdx.scenes.scene2d.ui.Table buildTopTable() -> l
    com.badlogic.gdx.scenes.scene2d.ui.Table buildPagedScrollPane() -> m
    com.badlogic.gdx.scenes.scene2d.ui.Button getLevelButton(com.nha.pelsdreams.utils.SaveGameHelper$LevelState) -> a
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> c
    void pause() -> e
    com.badlogic.gdx.InputProcessor getInputProcessor() -> h
    java.lang.String access$0() -> i
com.nha.pelsdreams.screens.LevelScreen$1 -> com.nha.pelsdreams.d.e:
    com.nha.pelsdreams.screens.LevelScreen this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.LevelScreen$2 -> com.nha.pelsdreams.d.f:
    com.nha.pelsdreams.screens.LevelScreen this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.LoadingScreen -> com.nha.pelsdreams.d.g:
    com.nha.pelsdreams.screens.AbstractGameScreen nextScreen -> e
    com.nha.pelsdreams.screens.actors.LoadingBarActor loadingBarActor -> f
    void rebuildStage() -> i
    void render(float) -> a
    void show() -> c
    void resize(int,int) -> a
    void pause() -> e
    com.badlogic.gdx.InputProcessor getInputProcessor() -> h
com.nha.pelsdreams.screens.MenuScreen -> com.nha.pelsdreams.d.h:
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> e
    com.badlogic.gdx.scenes.scene2d.ui.Button btnMenuPlay -> f
    com.badlogic.gdx.scenes.scene2d.ui.Button btnMenuSound -> g
    com.badlogic.gdx.scenes.scene2d.ui.Button btnMenuMusic -> h
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> c
    void pause() -> e
    void rebuildStage(float,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table buildBackgroundLayer() -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table buildControlsLayer() -> j
    void onPlayClicked() -> k
    void onSoundClicked() -> l
    void onMusicClicked() -> m
    void loadSettings() -> n
    void saveSettings() -> o
    com.badlogic.gdx.InputProcessor getInputProcessor() -> h
    void access$0(com.nha.pelsdreams.screens.MenuScreen) -> a
    void access$1(com.nha.pelsdreams.screens.MenuScreen) -> b
    void access$2(com.nha.pelsdreams.screens.MenuScreen) -> c
com.nha.pelsdreams.screens.MenuScreen$1 -> com.nha.pelsdreams.d.i:
    com.nha.pelsdreams.screens.MenuScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.nha.pelsdreams.screens.MenuScreen$2 -> com.nha.pelsdreams.d.j:
    com.nha.pelsdreams.screens.MenuScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.nha.pelsdreams.screens.MenuScreen$3 -> com.nha.pelsdreams.d.k:
    com.nha.pelsdreams.screens.MenuScreen this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.nha.pelsdreams.screens.WorldScreen -> com.nha.pelsdreams.d.l:
    java.lang.String TAG -> g
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> h
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener backClickListener -> e
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener worldClickListener -> f
    void rebuildStage() -> j
    com.badlogic.gdx.scenes.scene2d.ui.Table buildBackgroundTable() -> k
    com.badlogic.gdx.scenes.scene2d.ui.Table buildTopTable() -> l
    com.nha.pelsdreams.screens.transitions.PagedScrollPane buildPagedScrollPane() -> m
    com.badlogic.gdx.scenes.scene2d.ui.Button getWorldButton(int) -> a
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> c
    void pause() -> e
    com.badlogic.gdx.InputProcessor getInputProcessor() -> h
    java.lang.String access$0() -> i
com.nha.pelsdreams.screens.WorldScreen$1 -> com.nha.pelsdreams.d.m:
    com.nha.pelsdreams.screens.WorldScreen this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.WorldScreen$2 -> com.nha.pelsdreams.d.n:
    com.nha.pelsdreams.screens.WorldScreen this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.CompletedScreenActor -> com.nha.pelsdreams.d.a.a:
    com.badlogic.gdx.scenes.scene2d.ui.Label numberMainItem -> I
    com.badlogic.gdx.scenes.scene2d.ui.Label numberItem -> J
    void rebuildStage() -> af
    com.badlogic.gdx.scenes.scene2d.ui.Table buildStatisticsTable() -> ag
    void update() -> Y
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener continueClickListener() -> Z
com.nha.pelsdreams.screens.actors.CompletedScreenActor$1 -> com.nha.pelsdreams.d.a.b:
    com.nha.pelsdreams.screens.actors.CompletedScreenActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.GameGuiActor -> com.nha.pelsdreams.d.a.c:
    java.lang.String TAG -> n
    com.nha.pelsdreams.screens.GameScreen gameScreen -> o
    com.nha.pelsdreams.game.WorldController worldController -> p
    com.badlogic.gdx.utils.Array mainItems -> q
    int mainItemPadRight -> r
    int itemsVisual -> s
    com.badlogic.gdx.scenes.scene2d.ui.Label fpsLabel -> t
    com.badlogic.gdx.scenes.scene2d.ui.Label itemCounterLabel -> u
    com.badlogic.gdx.scenes.scene2d.ui.Label screenSizeLabel -> v
    void buildGUI() -> P
    com.badlogic.gdx.scenes.scene2d.ui.Table buildGuiMainItem() -> Q
    com.badlogic.gdx.scenes.scene2d.ui.Table buildGuiItem() -> R
    com.badlogic.gdx.scenes.scene2d.ui.Table buildPauseButton() -> S
    com.badlogic.gdx.scenes.scene2d.ui.Table buildUpControlButtons() -> T
    com.badlogic.gdx.scenes.scene2d.ui.Table buildDownControlButtons() -> U
    com.badlogic.gdx.scenes.scene2d.ui.Table buildFpsCounter() -> V
    com.badlogic.gdx.scenes.scene2d.ui.Table buildScreenSize() -> W
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void setAnimation(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    com.nha.pelsdreams.screens.GameScreen access$0(com.nha.pelsdreams.screens.actors.GameGuiActor) -> a
    java.lang.String access$1() -> O
com.nha.pelsdreams.screens.actors.GameGuiActor$1 -> com.nha.pelsdreams.d.a.d:
    com.nha.pelsdreams.screens.actors.GameGuiActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.GameOverScreenActor -> com.nha.pelsdreams.d.a.e:
    com.badlogic.gdx.scenes.scene2d.ui.Label labelYellow -> I
    void rebuildStage() -> af
    com.badlogic.gdx.scenes.scene2d.ui.Table buildObjetivesTable() -> ag
    void update() -> Y
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener continueClickListener() -> Z
com.nha.pelsdreams.screens.actors.InitScreenActor -> com.nha.pelsdreams.d.a.f:
    void rebuildStage() -> af
    com.badlogic.gdx.scenes.scene2d.ui.Table buildObjetivesTable() -> ag
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener continueClickListener() -> Z
com.nha.pelsdreams.screens.actors.InitScreenActor$1 -> com.nha.pelsdreams.d.a.g:
    com.nha.pelsdreams.screens.actors.InitScreenActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.LoadingBarActor -> com.nha.pelsdreams.d.a.h:
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence -> n
    void buildLoadingBar() -> Y
    com.badlogic.gdx.scenes.scene2d.ui.Image buildBall(float) -> j
    void setAnimation(com.badlogic.gdx.scenes.scene2d.Actor,float) -> a
com.nha.pelsdreams.screens.actors.NotCompletedScreenActor -> com.nha.pelsdreams.d.a.i:
    com.badlogic.gdx.scenes.scene2d.ui.Label numberMainItem -> I
    com.badlogic.gdx.scenes.scene2d.ui.Label numberItem -> J
    void rebuildStage() -> af
    com.badlogic.gdx.scenes.scene2d.ui.Table buildStatisticsTable() -> ag
    void update() -> Y
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener continueClickListener() -> Z
com.nha.pelsdreams.screens.actors.NotCompletedScreenActor$1 -> com.nha.pelsdreams.d.a.j:
    com.nha.pelsdreams.screens.actors.NotCompletedScreenActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.PauseScreenActor -> com.nha.pelsdreams.d.a.k:
    void rebuildStage() -> af
    com.badlogic.gdx.scenes.scene2d.ui.Table buildSoundTable() -> ag
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener continueClickListener() -> Z
com.nha.pelsdreams.screens.actors.PauseScreenActor$1 -> com.nha.pelsdreams.d.a.l:
    com.nha.pelsdreams.screens.actors.PauseScreenActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.ScreenActor -> com.nha.pelsdreams.d.a.m:
    com.nha.pelsdreams.screens.DirectedGame game -> n
    com.nha.pelsdreams.screens.GameScreen gameScreen -> o
    com.nha.pelsdreams.utils.SaveGameHelper$GameState gameState -> p
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> C
    com.badlogic.gdx.scenes.scene2d.ui.Table buttonsTable -> I
    com.badlogic.gdx.scenes.scene2d.ui.Button continueButton -> J
    com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType confirmType -> K
    com.badlogic.gdx.scenes.scene2d.ui.Stack stack -> L
    boolean isVisible -> D
    com.nha.pelsdreams.enums.ShowButtonsType showButtonsType -> M
    com.badlogic.gdx.scenes.scene2d.ui.Label confirmLabel2 -> N
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener yesClickListener -> E
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener noClickListener -> F
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener restartClickListener -> G
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener menuClickListener -> H
    int[] $SWITCH_TABLE$com$nha$pelsdreams$enums$ShowButtonsType -> O
    int[] $SWITCH_TABLE$com$nha$pelsdreams$screens$actors$ScreenActor$ConfirmType -> P
    com.badlogic.gdx.scenes.scene2d.ui.Stack buildContentTable(com.badlogic.gdx.scenes.scene2d.ui.Label,com.badlogic.gdx.scenes.scene2d.ui.Table,com.nha.pelsdreams.enums.ShowButtonsType) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table buildTopTable(com.badlogic.gdx.scenes.scene2d.ui.Label) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table buildBackgroundTable() -> aa
    com.badlogic.gdx.scenes.scene2d.ui.Table buildButtonsTable() -> ab
    com.badlogic.gdx.scenes.scene2d.ui.Table buildConfirmTable() -> ac
    void showConfirmOption(java.lang.Boolean,com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType) -> a
    void show(boolean,boolean) -> b
    void update() -> Y
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener continueClickListener() -> Z
    com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType access$0(com.nha.pelsdreams.screens.actors.ScreenActor) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Stack access$1(com.nha.pelsdreams.screens.actors.ScreenActor) -> b
    int[] $SWITCH_TABLE$com$nha$pelsdreams$enums$ShowButtonsType() -> ad
    int[] $SWITCH_TABLE$com$nha$pelsdreams$screens$actors$ScreenActor$ConfirmType() -> ae
com.nha.pelsdreams.screens.actors.ScreenActor$1 -> com.nha.pelsdreams.d.a.n:
    com.nha.pelsdreams.screens.actors.ScreenActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.ScreenActor$2 -> com.nha.pelsdreams.d.a.o:
    com.nha.pelsdreams.screens.actors.ScreenActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.ScreenActor$3 -> com.nha.pelsdreams.d.a.p:
    com.nha.pelsdreams.screens.actors.ScreenActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.ScreenActor$4 -> com.nha.pelsdreams.d.a.q:
    com.nha.pelsdreams.screens.actors.ScreenActor this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType -> com.nha.pelsdreams.d.a.r:
    com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType RESTART -> a
    com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType MENU -> b
    com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType[] ENUM$VALUES -> c
    com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType[] values() -> values
    com.nha.pelsdreams.screens.actors.ScreenActor$ConfirmType valueOf(java.lang.String) -> valueOf
com.nha.pelsdreams.screens.transitions.PagedScrollPane -> com.nha.pelsdreams.d.b.a:
    boolean wasPanDragFling -> R
    com.badlogic.gdx.scenes.scene2d.ui.Table content -> S
    void setup() -> Z
    void addPage(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    void act(float) -> a
    void setWidth(float) -> b
    void setPageSpacing(float) -> o
    void scrollToPage() -> aa
com.nha.pelsdreams.screens.transitions.ScreenTransition -> com.nha.pelsdreams.d.b.b:
    float getDuration() -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch,com.badlogic.gdx.utils.viewport.Viewport,com.badlogic.gdx.graphics.Texture,com.badlogic.gdx.graphics.Texture,float) -> a
com.nha.pelsdreams.screens.transitions.ScreenTransitionSlide -> com.nha.pelsdreams.d.b.c:
    com.nha.pelsdreams.screens.transitions.ScreenTransitionSlide instance -> a
    float duration -> b
    int direction -> c
    boolean slideOut -> d
    com.badlogic.gdx.math.Interpolation easing -> e
    com.nha.pelsdreams.screens.transitions.ScreenTransitionSlide init(float,int,boolean,com.badlogic.gdx.math.Interpolation) -> a
    float getDuration() -> a
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch,com.badlogic.gdx.utils.viewport.Viewport,com.badlogic.gdx.graphics.Texture,com.badlogic.gdx.graphics.Texture,float) -> a
com.nha.pelsdreams.utils.CameraHelper -> com.nha.pelsdreams.e.a:
    com.badlogic.gdx.math.Vector2 position -> a
    float zoom -> b
    com.nha.pelsdreams.game.objects.AbstractGameObject target -> c
    void update(float) -> a
    void setPosition(float,float) -> a
    com.badlogic.gdx.math.Vector2 getPosition() -> a
    void moveCamera(float,float) -> b
    void addZoom(float) -> b
    void setZoom(float) -> c
    void setTarget(com.nha.pelsdreams.game.objects.AbstractGameObject) -> a
    boolean hasTarget() -> b
    boolean hasTarget(com.nha.pelsdreams.game.objects.AbstractGameObject) -> b
    void applyTo(com.badlogic.gdx.graphics.OrthographicCamera) -> a
com.nha.pelsdreams.utils.Constants -> com.nha.pelsdreams.e.b:
    com.badlogic.gdx.math.Vector2 WORLD_GRAVITY -> a
    com.badlogic.gdx.math.Vector2 WORLD_GROUND_DIMENSION -> b
    float RUNNER_DENSITY -> c
    com.badlogic.gdx.math.Vector2 RUNNER_MAX_VELOCITY -> d
    com.badlogic.gdx.math.Vector2 RUNNER_DODGE -> e
    com.badlogic.gdx.math.Vector2 RUNNER_LINEAR_IMPULSE -> f
    com.badlogic.gdx.math.Vector2 RUNNER_JUMPING_LINEAR_IMPULSE -> g
    float ENEMY_JUMPER_DENSITY -> h
    com.badlogic.gdx.math.Vector2 ENEMY_JUMPER_MAX_VELOCITY -> i
    float ENEMY_HORIZONTAL_DENSITY -> j
    com.badlogic.gdx.math.Vector2 ENEMY_HORIZONTAL_MAX_VELOCITY -> k
com.nha.pelsdreams.utils.GamePreferences -> com.nha.pelsdreams.e.c:
    java.lang.String TAG -> a
    com.nha.pelsdreams.utils.GamePreferences instance -> b
    boolean sound -> c
    boolean music -> d
    com.badlogic.gdx.Preferences prefs -> e
    void load() -> a
    void save() -> b
com.nha.pelsdreams.utils.SaveGameHelper -> com.nha.pelsdreams.e.d:
    java.lang.String GAME_FILE -> a
    void saveGameState(com.nha.pelsdreams.utils.SaveGameHelper$GameState) -> a
    com.nha.pelsdreams.utils.SaveGameHelper$GameState loadGameState() -> a
    void writeFile(java.lang.String,java.lang.String) -> a
    java.lang.String readFile(java.lang.String) -> a
com.nha.pelsdreams.utils.SaveGameHelper$GameState -> com.nha.pelsdreams.e.e:
    com.nha.pelsdreams.utils.SaveGameHelper$WorldState currentWorld -> a
    com.badlogic.gdx.utils.Array worlds -> b
com.nha.pelsdreams.utils.SaveGameHelper$LevelState -> com.nha.pelsdreams.e.f:
    int id -> a
    boolean state -> b
    int mainItems -> c
com.nha.pelsdreams.utils.SaveGameHelper$WorldState -> com.nha.pelsdreams.e.g:
    int id -> a
    boolean state -> b
    com.nha.pelsdreams.utils.SaveGameHelper$LevelState currentLevel -> c
    com.badlogic.gdx.utils.Array levels -> d
com.nha.pelsdreams.utils.WorldUtils -> com.nha.pelsdreams.e.h:
    com.badlogic.gdx.physics.box2d.World createWorld() -> a
    void createRunner(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> a
    void createEnemyHorizontal(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> b
    void createEnemyJumpers(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> c
    void createEnemyStatic(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> d
    void createGround(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> e
    void createPlatforms(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> f
    void createMainItems(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> g
    void createItems(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> h
    void createPowerUps(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> i
    void createGoal(com.badlogic.gdx.physics.box2d.World,com.nha.pelsdreams.game.LevelCreator) -> j
    boolean bodyIsEnemyStatic(com.badlogic.gdx.physics.box2d.Body) -> a
    boolean bodyIsEnemyHorizontal(com.badlogic.gdx.physics.box2d.Body) -> b
    boolean bodyIsEnemyJumper(com.badlogic.gdx.physics.box2d.Body) -> c
    boolean bodyIsRunner(com.badlogic.gdx.physics.box2d.Body) -> d
    boolean bodyIsPlatform(com.badlogic.gdx.physics.box2d.Body) -> e
    boolean bodyIsGround(com.badlogic.gdx.physics.box2d.Body) -> f
    boolean bodyIsItem(com.badlogic.gdx.physics.box2d.Body) -> g
    boolean bodyIsMainItem(com.badlogic.gdx.physics.box2d.Body) -> h
    boolean bodyIsPowerUp(com.badlogic.gdx.physics.box2d.Body) -> i
    boolean bodyIsGoal(com.badlogic.gdx.physics.box2d.Body) -> j
